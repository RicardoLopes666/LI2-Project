        -:    0:Source:parte2/parte2.c
        -:    0:Graph:parte2/parte2.gcno
        -:    0:Data:parte2/parte2.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <stdbool.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte1/parte1.h"
        -:    5:#include <ctype.h> // Para usar a função isupper
        -:    6:#include <stdio.h>
        -:    7:#include "../parte3/parte3.h"
        -:    8:#include "../colors.h"
        -:    9:
        -:   10:// _________ Funções utilizadas para voltar atrás -> comando 'd' ____________
        -:   11:
       25:   12:bool initStackTabs(STACKTABS s)
        -:   13:{
       25:   14:    s->capacidade = 3;
       25:   15:    s->indice = 0;
       25:   16:    s->comprimento = 0;
       25:   17:    s->tabelas = malloc(sizeof(TABELA) * 3);
       25:   18:    if (s->tabelas == NULL)
    #####:   19:        return false;
        -:   20:    return true;
        -:   21:}
        -:   22:
        -:   23:// Função que insere uma tabela ao array de tabelas
       24:   24:bool insereTabela(STACKTABS s, TABELA tab)
        -:   25:{
       24:   26:    if (s->indice < s->comprimento) // Neste caso tem de se que dar free das tabela que estão para a frente e adicionar a nova tabela
        -:   27:    {
        2:   28:        for (int i = s->indice; i < s->comprimento; i++)
        1:   29:            freeTabela(s->tabelas[i]);
        -:   30:
        1:   31:        s->comprimento = s->indice;
        -:   32:    }
        -:   33:
       23:   34:    else if (s->comprimento >= s->capacidade)
        -:   35:    {
        1:   36:        s->capacidade = s->capacidade == 0 ? 1 : 2 * s->capacidade;
        1:   37:        TABELA *new;
        1:   38:        new = realloc(s->tabelas, s->capacidade * sizeof(TABELA));
        1:   39:        if (new == NULL)
        -:   40:            return false;
        1:   41:        s->tabelas = new;
        -:   42:    }
       24:   43:    s->tabelas[s->comprimento++] = tab;
       24:   44:    s->indice++;
       24:   45:    return true;
        -:   46:}
        -:   47:
        -:   48:TABELA copiarTabela(TABELA t); // Para poder usar em deleteTabela
        -:   49:
        5:   50:bool deleteTabela(GAME *game)
        -:   51:{                                                                         // Apenas se reduz o indice caso possivel
        5:   52:    if (game->stackTabs->comprimento <= 1 || game->stackTabs->indice < 2) // Dá erro se tentar eliminar a tabela inicial
        -:   53:        return false;
        2:   54:    freeTabela(game->tab);
        2:   55:    game->tab = copiarTabela(game->stackTabs->tabelas[game->stackTabs->indice-- - 2]);
        2:   56:    return true;
        -:   57:}
        -:   58:
       63:   59:void copiaLinha(int i, TABELA t, TABELA new)
        -:   60:{
      235:   61:    for (int j = 0; j <= t->c; j++)
        -:   62:    {
      172:   63:        if (j == t->c)
       63:   64:            new->tabela[i][j] = '\0';
        -:   65:        else
      109:   66:            new->tabela[i][j] = t->tabela[i][j];
        -:   67:    }
       63:   68:}
        -:   69:
        -:   70:// Função que faz uma cópia do elementos de uma tabela para uma outra criada com malloc e devolve o novo endereço
       39:   71:TABELA copiarTabela(TABELA t)
        -:   72:{
       39:   73:    TABELA new = malloc(sizeof(struct Tabela));
       39:   74:    if (new == NULL)
        -:   75:    {
        -:   76:        return NULL;
        -:   77:    }
       39:   78:    new->c = t->c;
       39:   79:    new->l = t->l;
       39:   80:    new->tabela = malloc(t->l * sizeof(char *));
       39:   81:    if (new->tabela == NULL)
        -:   82:    {
    #####:   83:        free(new);
    #####:   84:        return NULL;
        -:   85:    }
      102:   86:    for (int i = 0; i < t->l; i++)
        -:   87:    {
       63:   88:        new->tabela[i] = malloc((t->c + 1) * sizeof(char)); // + 1 para colocar o '\0'
       63:   89:        if (new->tabela[i] == NULL)
        -:   90:        {
    #####:   91:            for (int j = 0; j < i; j++)
        -:   92:            {
    #####:   93:                free(new->tabela[j]);
        -:   94:            }
    #####:   95:            free(new->tabela);
    #####:   96:            free(new);
    #####:   97:            return NULL;
        -:   98:        }
       63:   99:        copiaLinha(i, t, new);
        -:  100:    }
        -:  101:    return new;
        -:  102:}
        -:  103:
        -:  104:// Liberta a memória alocada para a lista de tabuleiros
       16:  105:void freeStackTabs(STACKTABS s)
        -:  106:{
       16:  107:    if (s != NULL)
        -:  108:    {
       25:  109:        for (int i = 0; i < s->comprimento; i++)
        -:  110:        {
       10:  111:            freeTabela(s->tabelas[i]);
        -:  112:        }
       15:  113:        free(s->tabelas);
       15:  114:        free(s);
        -:  115:    }
       16:  116:}
        -:  117:
        2:  118:void u(GAME *game, bool *comandoProcessado)
        -:  119:{
        2:  120:    if (game->stackTabs->indice >= game->stackTabs->comprimento)
        1:  121:        fprintf(stderr, "%sErro: Não existem tabuleiros mais para a frente%s\n", ERROR_COLOR, RESET);
        -:  122:    else
        -:  123:    {
        1:  124:        freeTabela(game->tab);
        1:  125:        game->tab = copiarTabela(game->stackTabs->tabelas[game->stackTabs->indice++]);
        -:  126:    }
        -:  127:
        2:  128:    *comandoProcessado = true;
        2:  129:}
        -:  130:
        2:  131:void d(GAME *game, bool *comandoProcessado)
        -:  132:{
        2:  133:    if (!deleteTabela(game))
        -:  134:    {
        1:  135:        fprintf(stderr, "%sErro: Não existem tabuleiros anteriores%s\n", ERROR_COLOR, RESET);
        -:  136:    }
        -:  137:
        2:  138:    *comandoProcessado = true;
        2:  139:}
        -:  140:
        -:  141:// _____ Funçãoes utilizadas para verificar as restrições -> comando 'v'______
        -:  142:
        -:  143:// Função auxiliar para verificar se uma célula está dentro dos limites do tabuleiro
      422:  144:bool dentroDosLimites(TABELA t, int linha, int coluna)
        -:  145:{
      422:  146:    return linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c;
        -:  147:}
        -:  148:
        -:  149:// Função que verifica a vizinhança de uma casa riscada e caso tenha alguma casa riscada conta como restrição
        -:  150:// Retorna o número de restrições violadas e preenche o array `restricoes` com as coordenadas
       17:  151:int verificaRiscadaVizinhasBrancas(TABELA t, int linha, int coluna, int restricoes[][2])
        -:  152:{
       17:  153:    if (!dentroDosLimites(t, linha, coluna) || t->tabela[linha][coluna] != '#')
        -:  154:    {
        -:  155:        return 0; // A célula não é uma casa riscada
        -:  156:    }
        -:  157:
       15:  158:    int direcoes[4][2] = {
        -:  159:        {-1, 0}, // Cima
        -:  160:        {1, 0},  // Baixo
        -:  161:        {0, -1}, // Esquerda
        -:  162:        {0, 1}   // Direita
        -:  163:    };
        -:  164:
       15:  165:    int count = 0; // Contador de restrições violadas
        -:  166:
       75:  167:    for (int i = 0; i < 4; i++)
        -:  168:    {
       60:  169:        int novaLinha = linha + direcoes[i][0];
       60:  170:        int novaColuna = coluna + direcoes[i][1];
        -:  171:
       60:  172:        if (dentroDosLimites(t, novaLinha, novaColuna))
        -:  173:        {
       32:  174:            if (t->tabela[novaLinha][novaColuna] == '#')
        -:  175:            {
        -:  176:                // Se encontrar uma casa riscada na vizinhança, adiciona como restrição
       12:  177:                restricoes[count][0] = novaLinha;
       12:  178:                restricoes[count][1] = novaColuna;
       12:  179:                count++;
        -:  180:            }
        -:  181:        }
        -:  182:    }
        -:  183:
        -:  184:    return count; // Retorna o número de restrições violadas
        -:  185:}
        -:  186:
        -:  187:// Função que verifica se existem duas casas brancas iguais na mesma linha ou coluna
       19:  188:bool verificaLetraIgualLinhaColuna(TABELA t, int linha, int coluna)
        -:  189:{
       19:  190:    if (!dentroDosLimites(t, linha, coluna) || !isupper(t->tabela[linha][coluna]))
        -:  191:    {
        -:  192:        return false; // A célula não é uma casa branca
        -:  193:    }
        -:  194:
        -:  195:    char letraMaiuscula = t->tabela[linha][coluna];
        -:  196:
        -:  197:    // Verifica a linha
       53:  198:    for (int j = 0; j < t->c; j++)
        -:  199:    {
       35:  200:        if (j != coluna && t->tabela[linha][j] == letraMaiuscula)
        -:  201:        {
        -:  202:            return true; // Encontrou outra casa branca igual na mesma linha
        -:  203:        }
        -:  204:    }
        -:  205:
        -:  206:    // Verifica a coluna
       44:  207:    for (int i = 0; i < t->l; i++)
        -:  208:    {
       30:  209:        if (i != linha && t->tabela[i][coluna] == letraMaiuscula)
        -:  210:        {
        -:  211:            return true; // Encontrou outra casa branca igual na mesma coluna
        -:  212:        }
        -:  213:    }
        -:  214:
        -:  215:    return false; // Não encontrou casas brancas iguais na mesma linha ou coluna
        -:  216:}
        -:  217:
        -:  218:// Função que trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       39:  219:void verificaRiscadasERepetidas(TABELA t, int i, int j, int *contaRestricoes, bool *temRestricoes, bool escreve)
        -:  220:{
        -:  221:    // Verifica restrições para casas riscadas
       39:  222:    if (t->tabela[i][j] == '#')
        -:  223:    {
       12:  224:        int restricoes[4][2]; // Máximo de 4 vizinhos
       12:  225:        int numRestricoes = verificaRiscadaVizinhasBrancas(t, i, j, restricoes);
        -:  226:
       12:  227:        if (numRestricoes > 0)
        -:  228:        {
        5:  229:            *temRestricoes = true;
        5:  230:            if (escreve)
        -:  231:            {
        1:  232:                printf("\n%s%s---- Restrição nº %d ----%s\n", HINT_COLOR, BOLD, *contaRestricoes + 1, RESET);
        1:  233:                printf("Casa riscada em (%c%d) tem restrições violadas (apenas deveria ter casas brancas na sua vizinhança) nas seguintes coordenadas:\n", 'a' + j, i + 1);
        -:  234:
        2:  235:                for (int k = 0; k < numRestricoes; k++)
        -:  236:                {
        1:  237:                    printf("  - Coluna: %c, Linha: %d\n", 'a' + restricoes[k][1], restricoes[k][0] + 1);
        -:  238:                }
        -:  239:            }
        5:  240:            (*contaRestricoes)++;
        -:  241:        }
        -:  242:    }
        -:  243:
        -:  244:    // Verifica restrições para casas brancas
       39:  245:    if (isupper(t->tabela[i][j]))
        -:  246:    {
       19:  247:        if (verificaLetraIgualLinhaColuna(t, i, j))
        -:  248:        {
        5:  249:            *temRestricoes = true;
        5:  250:            if (escreve)
        -:  251:            {
        1:  252:                printf("\n%s%s---- Restrição nº %d ----%s\n", HINT_COLOR, BOLD, *contaRestricoes + 1, RESET);
        1:  253:                printf("Casa branca em (%c%d) tem restrições violadas (letra repetida na mesma linha ou coluna).\n", 'a' + j, i + 1);
        -:  254:            }
        5:  255:            (*contaRestricoes)++;
        -:  256:        }
        -:  257:    }
       39:  258:}
        -:  259:
        -:  260:// Função que imprime as restrições do jogo caso estas existam
       13:  261:bool verificaRestricoes(TABELA t, bool escreve)
        -:  262:{
       13:  263:    bool temRestricoes = false;
       13:  264:    int contaRestricoes = 0;
        -:  265:    // Percorre todas as células do tabuleiro
       34:  266:    for (int i = 0; i < t->l; i++)
        -:  267:    {
       57:  268:        for (int j = 0; j < t->c; j++)
        -:  269:        {
        -:  270:            // Trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       36:  271:            verificaRiscadasERepetidas(t, i, j, &contaRestricoes, &temRestricoes, escreve);
        -:  272:        }
        -:  273:    }
        -:  274:
        -:  275:    // Função que chama as funções auxiliares necessarias para verificar se existem caminhos ortogonais e trata as respetivas mensagens no terminal
       13:  276:    if (!trataCaminhoOrtogonal(t, &contaRestricoes, &temRestricoes, escreve))
        -:  277:    {
        -:  278:        return false;
        -:  279:    }
        -:  280:
       13:  281:    if (!temRestricoes)
        -:  282:    {
       11:  283:        if (escreve)
        1:  284:            printf("%sNenhuma restrição foi violada no tabuleiro.%s\n", GREEN, RESET);
        -:  285:    }
        -:  286:
       13:  287:    return temRestricoes;
        -:  288:}
        -:  289:
        2:  290:void v(GAME game, bool *continuar, bool *comandoProcessado)
        -:  291:{
        2:  292:    if (game.tab == NULL)
        -:  293:    {
        1:  294:        fprintf(stderr, "%sErro: tabuleiro não carregado.%s\n", ERROR_COLOR, RESET);
        1:  295:        *continuar = false;
        -:  296:    }
        -:  297:    else
        -:  298:    {
        1:  299:        printf("%sA verificar as restrições do tabuleiro...%s\n", HINT_COLOR, RESET);
        1:  300:        verificaRestricoes(game.tab, true);
        1:  301:        *comandoProcessado = true;
        -:  302:    }
        2:  303:}
