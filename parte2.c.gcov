        -:    0:Source:parte2/parte2.c
        -:    0:Graph:parte2/parte2.gcno
        -:    0:Data:parte2/parte2.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <stdbool.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte1/parte1.h"
        -:    5:#include <ctype.h> // Para usar a função isupper
        -:    6:#include <stdio.h>
        -:    7:#include "../parte3/parte3.h"
        -:    8:#include "../colors.h"
        -:    9:
        -:   10:// _________ Funções utilizadas para voltar atrás -> comando 'd' ____________
        -:   11:
       18:   12:bool initStackTabs(STACKTABS s)
        -:   13:{
       18:   14:    s->capacidade = 3;
       18:   15:    s->comprimento = 0;
       18:   16:    s->tabelas = malloc(sizeof(TABELA) * 3);
       18:   17:    if (s->tabelas == NULL)
    #####:   18:        return false;
        -:   19:    return true;
        -:   20:}
        -:   21:
        -:   22:// Função que insere uma tabela ao array de tabelas
        9:   23:bool insereTabela(STACKTABS s, TABELA tab)
        -:   24:{
        9:   25:    if (s->comprimento >= s->capacidade)
        -:   26:    {
    #####:   27:        s->capacidade = s->capacidade == 0 ? 1 : 2 * s->capacidade;
    #####:   28:        TABELA *new;
    #####:   29:        new = realloc(s->tabelas, s->capacidade * sizeof(TABELA));
    #####:   30:        if (new == NULL)
        -:   31:            return false;
    #####:   32:        s->tabelas = new;
        -:   33:    }
        9:   34:    s->tabelas[s->comprimento++] = tab;
        9:   35:    return true;
        -:   36:}
        -:   37:
        -:   38:TABELA copiarTabela(TABELA t); // Para poder usar em deleteTabela
        -:   39:
        2:   40:bool deleteTabela(GAME *game)
        -:   41:{
        2:   42:    if (game->stackTabs->comprimento <= 1) // Dá erro se tentar eliminar a tabela inicial
        -:   43:        return false;
        1:   44:    freeTabela(game->stackTabs->tabelas[--game->stackTabs->comprimento]); // Liberta o espaço da tabela
        1:   45:    freeTabela(game->tab);
        1:   46:    game->tab = copiarTabela(game->stackTabs->tabelas[game->stackTabs->comprimento - 1]);
        1:   47:    return true;
        -:   48:}
        -:   49:
        -:   50:// Função que faz uma cópia do elementos de uma tabela para uma outra criada com malloc e devolve o novo endereço
       13:   51:TABELA copiarTabela(TABELA t)
        -:   52:{
       13:   53:    TABELA new = malloc(sizeof(struct Tabela));
       13:   54:    if (new == NULL)
        -:   55:    {
        -:   56:        return NULL;
        -:   57:    }
       13:   58:    new->c = t->c;
       13:   59:    new->l = t->l;
       13:   60:    new->tabela = malloc(t->l * sizeof(char *));
       13:   61:    if (new->tabela == NULL)
        -:   62:    {
    #####:   63:        free(new);
    #####:   64:        return NULL;
        -:   65:    }
       44:   66:    for (int i = 0; i < t->l; i++)
        -:   67:    {
       31:   68:        new->tabela[i] = malloc((t->c + 1) * sizeof(char)); // + 1 para colocar o '\0'
       31:   69:        if (new->tabela[i] == NULL)
        -:   70:        {
    #####:   71:            for (int j = 0; j < i; j++)
        -:   72:            {
    #####:   73:                free(new->tabela[j]);
        -:   74:            }
    #####:   75:            free(new->tabela);
    #####:   76:            free(new);
    #####:   77:            return NULL;
        -:   78:        }
      143:   79:        for (int j = 0; j <= t->c; j++)
        -:   80:        {
      112:   81:            if (j == t->c)
       31:   82:                new->tabela[i][j] = '\0';
        -:   83:            else
       81:   84:                new->tabela[i][j] = t->tabela[i][j];
        -:   85:        }
        -:   86:    }
        -:   87:    return new;
        -:   88:}
        -:   89:
        -:   90:// Liberta a memória alocada para a lista de tabuleiros
       18:   91:void freeStackTabs(STACKTABS s)
        -:   92:{
       18:   93:    if (s != NULL)
        -:   94:    {
       26:   95:        for (int i = 0; i < s->comprimento; i++)
        -:   96:        {
        8:   97:            freeTabela(s->tabelas[i]);
        -:   98:        }
       18:   99:        free(s->tabelas);
       18:  100:        free(s);
        -:  101:    }
       18:  102:}
        -:  103:
    #####:  104:void d(GAME *game, bool *comandoProcessado)
        -:  105:{
    #####:  106:    if (!deleteTabela(game))
        -:  107:    {
    #####:  108:        fprintf(stderr, "%sErro: não existem tabuleiros anteriores%s\n", ERROR_COLOR, RESET);
        -:  109:    }
        -:  110:    else
    #####:  111:        *comandoProcessado = true;
    #####:  112:}
        -:  113:
        -:  114:// _____ Funçãoes utilizadas para verificar as restrições -> comando 'v'______
        -:  115:
        -:  116:// Função auxiliar para verificar se uma célula está dentro dos limites do tabuleiro
      197:  117:bool dentroDosLimites(TABELA t, int linha, int coluna)
        -:  118:{
      197:  119:    return linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c;
        -:  120:}
        -:  121:
        -:  122:// Função que verifica a vizinhança de uma casa riscada e caso tenha alguma casa riscada conta como restrição
        -:  123:// Retorna o número de restrições violadas e preenche o array `restricoes` com as coordenadas
        2:  124:int verificaRiscadaVizinhasBrancas(TABELA t, int linha, int coluna, int restricoes[][2])
        -:  125:{
        2:  126:    if (!dentroDosLimites(t, linha, coluna) || t->tabela[linha][coluna] != '#')
        -:  127:    {
        -:  128:        return 0; // A célula não é uma casa riscada
        -:  129:    }
        -:  130:
        2:  131:    int direcoes[4][2] = {
        -:  132:        {-1, 0}, // Cima
        -:  133:        {1, 0},  // Baixo
        -:  134:        {0, -1}, // Esquerda
        -:  135:        {0, 1}   // Direita
        -:  136:    };
        -:  137:
        2:  138:    int count = 0; // Contador de restrições violadas
        -:  139:
       10:  140:    for (int i = 0; i < 4; i++)
        -:  141:    {
        8:  142:        int novaLinha = linha + direcoes[i][0];
        8:  143:        int novaColuna = coluna + direcoes[i][1];
        -:  144:
        8:  145:        if (dentroDosLimites(t, novaLinha, novaColuna))
        -:  146:        {
        6:  147:            if (t->tabela[novaLinha][novaColuna] == '#')
        -:  148:            {
        -:  149:                // Se encontrar uma casa riscada na vizinhança, adiciona como restrição
        1:  150:                restricoes[count][0] = novaLinha;
        1:  151:                restricoes[count][1] = novaColuna;
        1:  152:                count++;
        -:  153:            }
        -:  154:        }
        -:  155:    }
        -:  156:
        -:  157:    return count; // Retorna o número de restrições violadas
        -:  158:}
        -:  159:
        -:  160:// Função que verifica se existem duas casas brancas iguais na mesma linha ou coluna
        5:  161:bool verificaLetraIgualLinhaColuna(TABELA t, int linha, int coluna)
        -:  162:{
        5:  163:    if (!dentroDosLimites(t, linha, coluna) || !isupper(t->tabela[linha][coluna]))
        -:  164:    {
        -:  165:        return false; // A célula não é uma casa branca
        -:  166:    }
        -:  167:
        -:  168:    char letraMaiuscula = t->tabela[linha][coluna];
        -:  169:
        -:  170:    // Verifica a linha
       17:  171:    for (int j = 0; j < t->c; j++)
        -:  172:    {
       14:  173:        if (j != coluna && t->tabela[linha][j] == letraMaiuscula)
        -:  174:        {
        -:  175:            return true; // Encontrou outra casa branca igual na mesma linha
        -:  176:        }
        -:  177:    }
        -:  178:
        -:  179:    // Verifica a coluna
       12:  180:    for (int i = 0; i < t->l; i++)
        -:  181:    {
        9:  182:        if (i != linha && t->tabela[i][coluna] == letraMaiuscula)
        -:  183:        {
        -:  184:            return true; // Encontrou outra casa branca igual na mesma coluna
        -:  185:        }
        -:  186:    }
        -:  187:
        -:  188:    return false; // Não encontrou casas brancas iguais na mesma linha ou coluna
        -:  189:}
        -:  190:
        -:  191:// Função que trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       18:  192:void verificaRiscadasERepetidas(TABELA t, int i, int j, int *contaRestricoes, bool *temRestricoes, bool escreve)
        -:  193:{
        -:  194:    // Verifica restrições para casas riscadas
       18:  195:    if (t->tabela[i][j] == '#')
        -:  196:    {
        1:  197:        int restricoes[4][2]; // Máximo de 4 vizinhos
        1:  198:        int numRestricoes = verificaRiscadaVizinhasBrancas(t, i, j, restricoes);
        -:  199:
        1:  200:        if (numRestricoes > 0)
        -:  201:        {
    #####:  202:            *temRestricoes = true;
    #####:  203:            if (escreve)
        -:  204:            {
    #####:  205:                printf("\n---- Restrição nº %d ----\n", *contaRestricoes + 1);
    #####:  206:                printf("Casa riscada em (%c%d) tem restrições violadas (apenas deveria ter casas brancas na sua vizinhança) nas seguintes coordenadas:\n", 'a' + j, i + 1);
        -:  207:
    #####:  208:                for (int k = 0; k < numRestricoes; k++)
        -:  209:                {
    #####:  210:                    printf("  - Coluna: %c, Linha: %d\n", 'a' + restricoes[k][1], restricoes[k][0] + 1);
        -:  211:                }
        -:  212:            }
    #####:  213:            (*contaRestricoes)++;
        -:  214:        }
        -:  215:    }
        -:  216:
        -:  217:    // Verifica restrições para casas brancas
       18:  218:    if (isupper(t->tabela[i][j]))
        -:  219:    {
        5:  220:        if (verificaLetraIgualLinhaColuna(t, i, j))
        -:  221:        {
        2:  222:            *temRestricoes = true;
        2:  223:            if (escreve)
        -:  224:            {
    #####:  225:                printf("\n---- Restrição nº %d ----\n", *contaRestricoes + 1);
    #####:  226:                printf("Casa branca em (%c%d) tem restrições violadas (letra repetida na mesma linha ou coluna).\n", 'a' + j, i + 1);
        -:  227:            }
        2:  228:            (*contaRestricoes)++;
        -:  229:        }
        -:  230:    }
       18:  231:}
        -:  232:
        -:  233:// Função que imprime as restrições do jogo caso estas existam
        2:  234:bool verificaRestricoes(TABELA t, bool escreve)
        -:  235:{
        2:  236:    bool temRestricoes = false;
        2:  237:    int contaRestricoes = 0;
        -:  238:    // Percorre todas as células do tabuleiro
        8:  239:    for (int i = 0; i < t->l; i++)
        -:  240:    {
       24:  241:        for (int j = 0; j < t->c; j++)
        -:  242:        {
        -:  243:            // Trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       18:  244:            verificaRiscadasERepetidas(t, i, j, &contaRestricoes, &temRestricoes, escreve);
        -:  245:        }
        -:  246:    }
        -:  247:
        -:  248:    // Função que chama as funções auxiliares necessarias para verificar se existem caminhos ortogonais e trata as respetivas mensagens no terminal
        2:  249:    if (!trataCaminhoOrtogonal(t, &contaRestricoes, &temRestricoes, escreve))
        -:  250:    {
        -:  251:        return false;
        -:  252:    }
        -:  253:
        2:  254:    if (!temRestricoes)
        -:  255:    {
        1:  256:        if (escreve)
    #####:  257:            printf("Nenhuma restrição foi violada no tabuleiro.\n");
        -:  258:    }
        -:  259:
        2:  260:    return temRestricoes;
        -:  261:}
        -:  262:
    #####:  263:void v(GAME game, bool *continuar, bool *comandoProcessado)
        -:  264:{
    #####:  265:    if (game.tab == NULL)
        -:  266:    {
    #####:  267:        fprintf(stderr, "%sErro: tabuleiro não carregado.%s\n", ERROR_COLOR, RESET);
    #####:  268:        *continuar = false;
        -:  269:    }
        -:  270:    else
        -:  271:    {
    #####:  272:        printf("%sA verificar as restrições do tabuleiro...%s\n", HINT_COLOR, RESET);
    #####:  273:        verificaRestricoes(game.tab, true);
    #####:  274:        *comandoProcessado = true;
        -:  275:    }
    #####:  276:}
