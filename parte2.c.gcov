        -:    0:Source:parte2/parte2.c
        -:    0:Graph:parte2/parte2.gcno
        -:    0:Data:parte2/parte2.gcda
        -:    0:Runs:7
        -:    1:#include <stdlib.h>
        -:    2:#include <stdbool.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte1/parte1.h"
        -:    5:#include <ctype.h> // Para usar a função isupper
        -:    6:#include <stdio.h>
        -:    7:#include "../parte3/parte3.h"
        -:    8:
        -:    9:// _________ Funções utilizadas para voltar atrás -> comando 'd' ____________
        -:   10:
       35:   11:bool initStackTabs(STACKTABS s)
        -:   12:{
       35:   13:    s->capacidade = 3;
       35:   14:    s->comprimento = 0;
       35:   15:    s->tabelas = malloc(sizeof(TABELA) * 3);
       35:   16:    if (s->tabelas == NULL)
    #####:   17:        return false;
        -:   18:    return true;
        -:   19:}
        -:   20:
        -:   21:// Função que insere uma tabela ao array de tabelas
       42:   22:bool insereTabela(STACKTABS s, TABELA tab)
        -:   23:{
       42:   24:    if (s->comprimento >= s->capacidade)
        -:   25:    {
       12:   26:        s->capacidade = s->capacidade == 0 ? 1 : 2 * s->capacidade;
       12:   27:        TABELA *new;
       12:   28:        new = realloc(s->tabelas, s->capacidade * sizeof(TABELA));
       12:   29:        if (new == NULL)
        -:   30:            return false;
       12:   31:        s->tabelas = new;
        -:   32:    }
       42:   33:    s->tabelas[s->comprimento++] = tab;
       42:   34:    return true;
        -:   35:}
        -:   36:
        -:   37:TABELA copiarTabela(TABELA t); // Para poder usar em deleteTabela
        -:   38:
       14:   39:bool deleteTabela(GAME *game)
        -:   40:{
       14:   41:    if (game->stackTabs->comprimento <= 1) // Dá erro se tentar eliminar a tabela inicial
        -:   42:        return false;
        7:   43:    freeTabela(game->stackTabs->tabelas[--game->stackTabs->comprimento]); // Liberta o espaço da tabela
        7:   44:    freeTabela(game->tab);
        7:   45:    game->tab = copiarTabela(game->stackTabs->tabelas[game->stackTabs->comprimento - 1]);
        7:   46:    return true;
        -:   47:}
        -:   48:
        -:   49:// Função que faz uma cópia do elementos de uma tabela para uma outra criada com malloc e devolve o novo endereço
       28:   50:TABELA copiarTabela(TABELA t)
        -:   51:{
       28:   52:    TABELA new = malloc(sizeof(struct Tabela));
       28:   53:    if (new == NULL)
        -:   54:    {
        -:   55:        return NULL;
        -:   56:    }
       28:   57:    new->c = t->c;
       28:   58:    new->l = t->l;
       28:   59:    new->tabela = malloc(t->l * sizeof(char *));
       28:   60:    if (new->tabela == NULL)
        -:   61:    {
    #####:   62:        free(new);
    #####:   63:        return NULL;
        -:   64:    }
       91:   65:    for (int i = 0; i < t->l; i++)
        -:   66:    {
       63:   67:        new->tabela[i] = malloc((t->c + 1) * sizeof(char)); // + 1 para colocar o '\0'
       63:   68:        if (new->tabela[i] == NULL)
        -:   69:        {
    #####:   70:            for (int j = 0; j < i; j++)
        -:   71:            {
    #####:   72:                free(t->tabela[i]);
        -:   73:            }
    #####:   74:            free(new->tabela);
    #####:   75:            free(new);
    #####:   76:            return NULL;
        -:   77:        }
      273:   78:        for (int j = 0; j <= t->c; j++)
        -:   79:        {
      210:   80:            if (j == t->c)
       63:   81:                new->tabela[i][j] = '\0';
        -:   82:            else
      147:   83:                new->tabela[i][j] = t->tabela[i][j];
        -:   84:        }
        -:   85:    }
        -:   86:    return new;
        -:   87:}
        -:   88:
        -:   89:// Liberta a memória alocada para a lista de tabuleiros
       42:   90:void freeStackTabs(STACKTABS s)
        -:   91:{
       42:   92:    if (s != NULL)
        -:   93:    {
       70:   94:        for (int i = 0; i < s->comprimento; i++)
        -:   95:        {
       35:   96:            freeTabela(s->tabelas[i]);
        -:   97:        }
       35:   98:        free(s->tabelas);
       35:   99:        free(s);
        -:  100:    }
       42:  101:}
        -:  102:
        -:  103:// _____ Funçãoes utilizadas para verificar as restrições -> comando 'v'______
        -:  104:
        -:  105:// Função auxiliar para verificar se uma célula está dentro dos limites do tabuleiro
      567:  106:bool dentroDosLimites(TABELA t, int linha, int coluna)
        -:  107:{
      567:  108:    return linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c;
        -:  109:}
        -:  110:
        -:  111:// Função que verifica se todas as casas ao redor de uma casa riscada estão pintadas de branco
        -:  112:// Retorna o número de restrições violadas e preenche o array `restricoes` com as coordenadas
       14:  113:int verificaRiscadaVizinhasBrancas(TABELA t, int linha, int coluna, int restricoes[][2])
        -:  114:{
       14:  115:    if (!dentroDosLimites(t, linha, coluna) || t->tabela[linha][coluna] != '#')
        -:  116:    {
        -:  117:        return 0; // A célula não é uma casa riscada
        -:  118:    }
        -:  119:
       14:  120:    int direcoes[4][2] = {
        -:  121:        {-1, 0}, // Cima
        -:  122:        {1, 0},  // Baixo
        -:  123:        {0, -1}, // Esquerda
        -:  124:        {0, 1}   // Direita
        -:  125:    };
        -:  126:
       14:  127:    int count = 0; // Contador de restrições violadas
        -:  128:
       70:  129:    for (int i = 0; i < 4; i++)
        -:  130:    {
       56:  131:        int novaLinha = linha + direcoes[i][0];
       56:  132:        int novaColuna = coluna + direcoes[i][1];
        -:  133:
       56:  134:        if (dentroDosLimites(t, novaLinha, novaColuna))
        -:  135:        {
       42:  136:            if (!isupper(t->tabela[novaLinha][novaColuna]))
        -:  137:            {
        -:  138:                // Adiciona a coordenada da restrição violada ao array
       21:  139:                restricoes[count][0] = novaLinha;
       21:  140:                restricoes[count][1] = novaColuna;
       21:  141:                count++;
        -:  142:            }
        -:  143:        }
        -:  144:    }
        -:  145:
        -:  146:    return count; // Retorna o número de restrições violadas
        -:  147:}
        -:  148:
        -:  149:// Função que verifica se existe alguma letra igual (maiúscula ou minúscula) na mesma linha ou coluna de uma casa branca
        -:  150:// Função que verifica se existem duas casas brancas iguais na mesma linha ou coluna
        7:  151:bool verificaLetraIgualLinhaColuna(TABELA t, int linha, int coluna)
        -:  152:{
        7:  153:    if (!dentroDosLimites(t, linha, coluna) || !isupper(t->tabela[linha][coluna]))
        -:  154:    {
        -:  155:        return false; // A célula não é uma casa branca
        -:  156:    }
        -:  157:
        -:  158:    char letraMaiuscula = t->tabela[linha][coluna];
        -:  159:
        -:  160:    // Verifica a linha
       28:  161:    for (int j = 0; j < t->c; j++)
        -:  162:    {
       21:  163:        if (j != coluna && t->tabela[linha][j] == letraMaiuscula)
        -:  164:        {
        -:  165:            return true; // Encontrou outra casa branca igual na mesma linha
        -:  166:        }
        -:  167:    }
        -:  168:
        -:  169:    // Verifica a coluna
       28:  170:    for (int i = 0; i < t->l; i++)
        -:  171:    {
       21:  172:        if (i != linha && t->tabela[i][coluna] == letraMaiuscula)
        -:  173:        {
        -:  174:            return true; // Encontrou outra casa branca igual na mesma coluna
        -:  175:        }
        -:  176:    }
        -:  177:
        -:  178:    return false; // Não encontrou casas brancas iguais na mesma linha ou coluna
        -:  179:}
        -:  180:
        -:  181:// Função que imprime as restrições do jogo caso estas existam
        7:  182:bool verificaRestricoes(TABELA t)
        -:  183:{
        7:  184:    bool temRestricoes = false;
        7:  185:    int contaRestricoes = 0;
        -:  186:    // Percorre todas as células do tabuleiro
       28:  187:    for (int i = 0; i < t->l; i++)
        -:  188:    {
       84:  189:        for (int j = 0; j < t->c; j++)
        -:  190:        {
        -:  191:            // Verifica restrições para casas riscadas
       63:  192:            if (t->tabela[i][j] == '#')
        -:  193:            {
        7:  194:                int restricoes[4][2]; // Máximo de 4 vizinhos
        7:  195:                int numRestricoes = verificaRiscadaVizinhasBrancas(t, i, j, restricoes);
        -:  196:
        7:  197:                if (numRestricoes > 0)
        -:  198:                {
        7:  199:                    temRestricoes = true;
        7:  200:                    printf("\n---- Restrição nº %d ----\n", contaRestricoes + 1);
        7:  201:                    printf("Casa riscada em (%c%d) tem restrições violadas (apenas deveria ter casas brancas na sua vizinhança) nas seguintes coordenadas:\n", 'a' + j, i + 1);
       21:  202:                    for (int k = 0; k < numRestricoes; k++)
        -:  203:                    {
       14:  204:                        printf("  - Coluna: %c, Linha: %d\n", 'a' + restricoes[k][1], restricoes[k][0] + 1);
        -:  205:                    }
        7:  206:                    contaRestricoes++;
        -:  207:                }
        -:  208:            }
        -:  209:
        -:  210:            // Verifica restrições para casas brancas
       63:  211:            if (isupper(t->tabela[i][j]))
        -:  212:            {
        7:  213:                if (verificaLetraIgualLinhaColuna(t, i, j))
        -:  214:                {
    #####:  215:                    temRestricoes = true;
    #####:  216:                    printf("\n---- Restrição nº %d ----\n", contaRestricoes + 1);
    #####:  217:                    printf("Casa branca em (%c%d) tem restrições violadas (letra repetida na mesma linha ou coluna).\n", 'a' + j, i + 1);
    #####:  218:                    contaRestricoes++;
        -:  219:                }
        -:  220:            }
        -:  221:        }
        -:  222:    }
        -:  223:
        -:  224:    // Função que chama as funções auxiliares necessarias para verificar se existem caminhos ortogonais e trata as respetivas mensagens no terminal
        7:  225:    if (!trataCaminhoOrtogonal(t, &contaRestricoes, &temRestricoes))
        -:  226:    {
        -:  227:        return false;
        -:  228:    }
        -:  229:
        7:  230:    if (!temRestricoes)
        -:  231:    {
    #####:  232:        printf("Nenhuma restrição foi violada no tabuleiro.\n");
        -:  233:    }
        -:  234:
        7:  235:    return temRestricoes;
        -:  236:}
