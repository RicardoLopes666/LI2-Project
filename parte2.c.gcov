        -:    0:Source:parte2/parte2.c
        -:    0:Graph:parte2/parte2.gcno
        -:    0:Data:parte2/parte2.gcda
        -:    0:Runs:2
        -:    1:#include <stdlib.h>
        -:    2:#include <stdbool.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte1/parte1.h"
        -:    5:#include <ctype.h> // Para usar a função isupper
        -:    6:#include <stdio.h>
        -:    7:#include "../parte3/parte3.h"
        -:    8:
        -:    9:// _________ Funções utilizadas para voltar atrás -> comando 'd' ____________
        -:   10:
       36:   11:bool initStackTabs(STACKTABS s)
        -:   12:{
       36:   13:    s->capacidade = 3;
       36:   14:    s->comprimento = 0;
       36:   15:    s->tabelas = malloc(sizeof(TABELA) * 3);
       36:   16:    if (s->tabelas == NULL)
    #####:   17:        return false;
        -:   18:    return true;
        -:   19:}
        -:   20:
        -:   21:// Função que insere uma tabela ao array de tabelas
       18:   22:bool insereTabela(STACKTABS s, TABELA tab)
        -:   23:{
       18:   24:    if (s->comprimento >= s->capacidade)
        -:   25:    {
    #####:   26:        s->capacidade = s->capacidade == 0 ? 1 : 2 * s->capacidade;
    #####:   27:        TABELA *new;
    #####:   28:        new = realloc(s->tabelas, s->capacidade * sizeof(TABELA));
    #####:   29:        if (new == NULL)
        -:   30:            return false;
    #####:   31:        s->tabelas = new;
        -:   32:    }
       18:   33:    s->tabelas[s->comprimento++] = tab;
       18:   34:    return true;
        -:   35:}
        -:   36:
        -:   37:TABELA copiarTabela(TABELA t); // Para poder usar em deleteTabela
        -:   38:
        4:   39:bool deleteTabela(GAME *game)
        -:   40:{
        4:   41:    if (game->stackTabs->comprimento <= 1) // Dá erro se tentar eliminar a tabela inicial
        -:   42:        return false;
        2:   43:    freeTabela(game->stackTabs->tabelas[--game->stackTabs->comprimento]); // Liberta o espaço da tabela
        2:   44:    freeTabela(game->tab);
        2:   45:    game->tab = copiarTabela(game->stackTabs->tabelas[game->stackTabs->comprimento - 1]);
        2:   46:    return true;
        -:   47:}
        -:   48:
        -:   49:// Função que faz uma cópia do elementos de uma tabela para uma outra criada com malloc e devolve o novo endereço
       14:   50:TABELA copiarTabela(TABELA t)
        -:   51:{
       14:   52:    TABELA new = malloc(sizeof(struct Tabela));
       14:   53:    if (new == NULL)
        -:   54:    {
        -:   55:        return NULL;
        -:   56:    }
       14:   57:    new->c = t->c;
       14:   58:    new->l = t->l;
       14:   59:    new->tabela = malloc(t->l * sizeof(char *));
       14:   60:    if (new->tabela == NULL)
        -:   61:    {
    #####:   62:        free(new);
    #####:   63:        return NULL;
        -:   64:    }
       40:   65:    for (int i = 0; i < t->l; i++)
        -:   66:    {
       26:   67:        new->tabela[i] = malloc((t->c + 1) * sizeof(char)); // + 1 para colocar o '\0'
       26:   68:        if (new->tabela[i] == NULL)
        -:   69:        {
    #####:   70:            for (int j = 0; j < i; j++)
        -:   71:            {
    #####:   72:                free(new->tabela[j]);
        -:   73:            }
    #####:   74:            free(new->tabela);
    #####:   75:            free(new);
    #####:   76:            return NULL;
        -:   77:        }
      106:   78:        for (int j = 0; j <= t->c; j++)
        -:   79:        {
       80:   80:            if (j == t->c)
       26:   81:                new->tabela[i][j] = '\0';
        -:   82:            else
       54:   83:                new->tabela[i][j] = t->tabela[i][j];
        -:   84:        }
        -:   85:    }
        -:   86:    return new;
        -:   87:}
        -:   88:
        -:   89:// Liberta a memória alocada para a lista de tabuleiros
       36:   90:void freeStackTabs(STACKTABS s)
        -:   91:{
       36:   92:    if (s != NULL)
        -:   93:    {
       52:   94:        for (int i = 0; i < s->comprimento; i++)
        -:   95:        {
       16:   96:            freeTabela(s->tabelas[i]);
        -:   97:        }
       36:   98:        free(s->tabelas);
       36:   99:        free(s);
        -:  100:    }
       36:  101:}
        -:  102:
    #####:  103:void d(GAME *game, bool *comandoProcessado)
        -:  104:{
    #####:  105:    if (!deleteTabela(game))
        -:  106:    {
    #####:  107:        fprintf(stderr, "Erro: não existem tabuleiros anteriores\n");
        -:  108:    }
        -:  109:    else
    #####:  110:        *comandoProcessado = true;
    #####:  111:}
        -:  112:
        -:  113:// _____ Funçãoes utilizadas para verificar as restrições -> comando 'v'______
        -:  114:
        -:  115:// Função auxiliar para verificar se uma célula está dentro dos limites do tabuleiro
      156:  116:bool dentroDosLimites(TABELA t, int linha, int coluna)
        -:  117:{
      156:  118:    return linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c;
        -:  119:}
        -:  120:
        -:  121:// Função que verifica a vizinhança de uma casa riscada e caso tenha alguma casa riscada conta como restrição
        -:  122:// Retorna o número de restrições violadas e preenche o array `restricoes` com as coordenadas
        4:  123:int verificaRiscadaVizinhasBrancas(TABELA t, int linha, int coluna, int restricoes[][2])
        -:  124:{
        4:  125:    if (!dentroDosLimites(t, linha, coluna) || t->tabela[linha][coluna] != '#')
        -:  126:    {
        -:  127:        return 0; // A célula não é uma casa riscada
        -:  128:    }
        -:  129:
        4:  130:    int direcoes[4][2] = {
        -:  131:        {-1, 0}, // Cima
        -:  132:        {1, 0},  // Baixo
        -:  133:        {0, -1}, // Esquerda
        -:  134:        {0, 1}   // Direita
        -:  135:    };
        -:  136:
        4:  137:    int count = 0; // Contador de restrições violadas
        -:  138:
       20:  139:    for (int i = 0; i < 4; i++)
        -:  140:    {
       16:  141:        int novaLinha = linha + direcoes[i][0];
       16:  142:        int novaColuna = coluna + direcoes[i][1];
        -:  143:
       16:  144:        if (dentroDosLimites(t, novaLinha, novaColuna))
        -:  145:        {
       12:  146:            if (t->tabela[novaLinha][novaColuna] == '#')
        -:  147:            {
        -:  148:                // Se encontrar uma casa riscada na vizinhança, adiciona como restrição
        2:  149:                restricoes[count][0] = novaLinha;
        2:  150:                restricoes[count][1] = novaColuna;
        2:  151:                count++;
        -:  152:            }
        -:  153:        }
        -:  154:    }
        -:  155:
        -:  156:    return count; // Retorna o número de restrições violadas
        -:  157:}
        -:  158:
        -:  159:// Função que verifica se existem duas casas brancas iguais na mesma linha ou coluna
        4:  160:bool verificaLetraIgualLinhaColuna(TABELA t, int linha, int coluna)
        -:  161:{
        4:  162:    if (!dentroDosLimites(t, linha, coluna) || !isupper(t->tabela[linha][coluna]))
        -:  163:    {
        -:  164:        return false; // A célula não é uma casa branca
        -:  165:    }
        -:  166:
        -:  167:    char letraMaiuscula = t->tabela[linha][coluna];
        -:  168:
        -:  169:    // Verifica a linha
       10:  170:    for (int j = 0; j < t->c; j++)
        -:  171:    {
       10:  172:        if (j != coluna && t->tabela[linha][j] == letraMaiuscula)
        -:  173:        {
        -:  174:            return true; // Encontrou outra casa branca igual na mesma linha
        -:  175:        }
        -:  176:    }
        -:  177:
        -:  178:    // Verifica a coluna
    #####:  179:    for (int i = 0; i < t->l; i++)
        -:  180:    {
    #####:  181:        if (i != linha && t->tabela[i][coluna] == letraMaiuscula)
        -:  182:        {
        -:  183:            return true; // Encontrou outra casa branca igual na mesma coluna
        -:  184:        }
        -:  185:    }
        -:  186:
        -:  187:    return false; // Não encontrou casas brancas iguais na mesma linha ou coluna
        -:  188:}
        -:  189:
        -:  190:// Função que trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       18:  191:void verificaRiscadasERepetidas(TABELA t, int i, int j, int *contaRestricoes, bool *temRestricoes, bool escreve)
        -:  192:{
        -:  193:    // Verifica restrições para casas riscadas
       18:  194:    if (t->tabela[i][j] == '#')
        -:  195:    {
        2:  196:        int restricoes[4][2]; // Máximo de 4 vizinhos
        2:  197:        int numRestricoes = verificaRiscadaVizinhasBrancas(t, i, j, restricoes);
        -:  198:
        2:  199:        if (numRestricoes > 0)
        -:  200:        {
    #####:  201:            *temRestricoes = true;
    #####:  202:            if (escreve)
        -:  203:            {
    #####:  204:                printf("\n---- Restrição nº %d ----\n", *contaRestricoes + 1);
    #####:  205:                printf("Casa riscada em (%c%d) tem restrições violadas (apenas deveria ter casas brancas na sua vizinhança) nas seguintes coordenadas:\n", 'a' + j, i + 1);
        -:  206:
    #####:  207:                for (int k = 0; k < numRestricoes; k++)
        -:  208:                {
    #####:  209:                    printf("  - Coluna: %c, Linha: %d\n", 'a' + restricoes[k][1], restricoes[k][0] + 1);
        -:  210:                }
        -:  211:            }
    #####:  212:            (*contaRestricoes)++;
        -:  213:        }
        -:  214:    }
        -:  215:
        -:  216:    // Verifica restrições para casas brancas
       18:  217:    if (isupper(t->tabela[i][j]))
        -:  218:    {
        4:  219:        if (verificaLetraIgualLinhaColuna(t, i, j))
        -:  220:        {
        4:  221:            *temRestricoes = true;
        4:  222:            if (escreve)
        -:  223:            {
    #####:  224:                printf("\n---- Restrição nº %d ----\n", *contaRestricoes + 1);
    #####:  225:                printf("Casa branca em (%c%d) tem restrições violadas (letra repetida na mesma linha ou coluna).\n", 'a' + j, i + 1);
        -:  226:            }
        4:  227:            (*contaRestricoes)++;
        -:  228:        }
        -:  229:    }
       18:  230:}
        -:  231:
        -:  232:// Função que imprime as restrições do jogo caso estas existam
        2:  233:bool verificaRestricoes(TABELA t, bool escreve)
        -:  234:{
        2:  235:    bool temRestricoes = false;
        2:  236:    int contaRestricoes = 0;
        -:  237:    // Percorre todas as células do tabuleiro
        8:  238:    for (int i = 0; i < t->l; i++)
        -:  239:    {
       24:  240:        for (int j = 0; j < t->c; j++)
        -:  241:        {
        -:  242:            // Trata das restrições que são vistas casa a casa (colocar em branco à volta de uma riscada e avisar letras que se repetem maiusculas)
       18:  243:            verificaRiscadasERepetidas(t, i, j, &contaRestricoes, &temRestricoes, escreve);
        -:  244:        }
        -:  245:    }
        -:  246:
        -:  247:    // Função que chama as funções auxiliares necessarias para verificar se existem caminhos ortogonais e trata as respetivas mensagens no terminal
        2:  248:    if (!trataCaminhoOrtogonal(t, &contaRestricoes, &temRestricoes, escreve))
        -:  249:    {
        -:  250:        return false;
        -:  251:    }
        -:  252:
        2:  253:    if (!temRestricoes)
        -:  254:    {
    #####:  255:        if (escreve)
    #####:  256:            printf("Nenhuma restrição foi violada no tabuleiro.\n");
        -:  257:    }
        -:  258:
        2:  259:    return temRestricoes;
        -:  260:}
        -:  261:
    #####:  262:void v(GAME game, bool *continuar, bool *comandoProcessado)
        -:  263:{
    #####:  264:    if (game.tab == NULL)
        -:  265:    {
    #####:  266:        fprintf(stderr, "Erro: tabuleiro não carregado.\n");
    #####:  267:        *continuar = false;
        -:  268:    }
        -:  269:    else
        -:  270:    {
    #####:  271:        printf("A verificar as restrições do tabuleiro...\n");
    #####:  272:        verificaRestricoes(game.tab, true);
    #####:  273:        *comandoProcessado = true;
        -:  274:    }
    #####:  275:}
