        -:    0:Source:parte3/parte3.c
        -:    0:Graph:parte3/parte3.gcno
        -:    0:Data:parte3/parte3.gcda
        -:    0:Runs:4
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte2/parte2.h"
        -:    5:#include <ctype.h>
        -:    6:#include "../colors.h"
        -:    7:
        -:    8:// Função que percorre a tabela por ordem de linhas e colunas até encontrar o primeiro elemento que não estiver riscado.
        -:    9:// Esse elemento será utilizado para o BFS e devolvido como uma coordenada.
       80:   10:COORDENADA devolvePrimeiroNRiscado(TABELA t)
        -:   11:{
       80:   12:    int i = 0;
        -:   13:    // Percorre a tabela até encontrar uma casa não riscada ('#')
      121:   14:    while (i < (t->c * t->l) && t->tabela[i / t->c][i % t->c] == '#')
       41:   15:        i++;
       80:   16:    if (i >= t->c * t->l) // Se todas as casas estão riscadas, retorna NULL
        -:   17:        return NULL;
        -:   18:
        -:   19:    // Aloca memória para a coordenada e define os valores de linha e coluna
       76:   20:    COORDENADA pos = malloc(sizeof(struct Coordenada));
       76:   21:    pos->l = i / t->c;
       76:   22:    pos->c = i % t->c;
       76:   23:    return pos;
        -:   24:}
        -:   25:
        -:   26:// Função que inicializa o array de visitados com 0, exceto nas casas riscadas (0 -> não visitado, 1 -> visitado).
        -:   27:// Também atualiza o contador `count` com o número de casas já visitadas.
       80:   28:int **initVisited(TABELA t, int *count)
        -:   29:{
       80:   30:    int **visited = malloc(sizeof(int *) * t->l); // Aloca memória para as linhas
      260:   31:    for (int i = 0; i < t->l; i++)
        -:   32:    {
      180:   33:        visited[i] = malloc(sizeof(int) * t->c); // Aloca memória para as colunas
      608:   34:        for (int j = 0; j < t->c; j++)
        -:   35:        {
      428:   36:            if (t->tabela[i][j] == '#') // Marca casas riscadas como visitadas
        -:   37:            {
       96:   38:                visited[i][j] = 1;
       96:   39:                (*count)++; // Atualiza o número de casas visitadas
        -:   40:            }
        -:   41:            else
      332:   42:                visited[i][j] = 0; // Marca casas não riscadas como não visitadas
        -:   43:        }
        -:   44:    }
       80:   45:    return visited;
        -:   46:}
        -:   47:
        -:   48:// Inicializa a fila (queue) com capacidade inicial de 3 elementos.
       80:   49:void initQueue(CQUEUE q)
        -:   50:{
       80:   51:    q->capacidade = 3;
       80:   52:    q->tamanho = 0;
       80:   53:    q->front = 0;
       80:   54:    q->list = malloc(sizeof(COORDENADA) * q->capacidade); // Aloca memória para a lista de coordenadas
       80:   55:}
        -:   56:
        -:   57:// Função responsável por inserir um array de coordenadas na fila.
        -:   58:// Expande a capacidade da fila, se necessário.
      346:   59:int insertQueue(CQUEUE q, COORDENADA *coordenadas, int coordSize)
        -:   60:{
      346:   61:    if (coordSize < 1) // Não há elementos para inserir
        -:   62:        return 1;
        -:   63:
      223:   64:    int tam = q->tamanho + coordSize;
      223:   65:    if (tam >= q->capacidade) // Expande a capacidade da fila, se necessário
        -:   66:    {
        -:   67:        int oldCapacity = q->capacidade;
       26:   68:        while (tam >= q->capacidade)
       13:   69:            q->capacidade = q->capacidade == 0 ? 1 : q->capacidade * 2; // Dobra a capacidade até ter espaço suficiente
        -:   70:
       13:   71:        COORDENADA *temp = realloc(q->list, sizeof(COORDENADA) * q->capacidade);
       13:   72:        if (temp == NULL) // Falha ao realocar memória
        -:   73:        {
        -:   74:            return 0;
        -:   75:        }
       13:   76:        q->list = temp;
        -:   77:
        -:   78:        // Ajusta os elementos da fila para manter a ordem correta
       13:   79:        int end = q->front + q->tamanho;
       13:   80:        if (end > oldCapacity)
    #####:   81:            for (int i = 0; i < end % oldCapacity; i++)
    #####:   82:                q->list[i + oldCapacity] = q->list[i];
        -:   83:    }
        -:   84:
        -:   85:    // Insere os novos elementos na fila
      509:   86:    for (int i = 0; i < coordSize; i++)
        -:   87:    {
      286:   88:        q->list[(q->front + q->tamanho) % q->capacidade] = coordenadas[i];
      286:   89:        q->tamanho++;
        -:   90:    }
        -:   91:    return 1;
        -:   92:}
        -:   93:
        -:   94:// Função que remove o elemento da frente da fila.
        -:   95:// O elemento removido é retornado por meio do ponteiro `pos`.
      286:   96:void deleteQueue(CQUEUE q, COORDENADA *pos)
        -:   97:{
      286:   98:    if (q->tamanho == 0) // Fila vazia
        -:   99:        return;
        -:  100:
        -:  101:    // Remove o elemento da frente
      286:  102:    COORDENADA temp = q->list[q->front];
      286:  103:    *pos = temp;
      286:  104:    q->list[q->front] = NULL;                  // Marca a posição como vazia
      286:  105:    q->front = (q->front + 1) % q->capacidade; // Atualiza o índice do início da fila
      286:  106:    q->tamanho--;
        -:  107:}
        -:  108:
        -:  109:// Função que, dado um array de visitados, devolve um array com as posições que não foram visitadas.
       19:  110:COORDENADA *devolveNaoVisitados(int **visited, int l, int c, int length)
        -:  111:{
       19:  112:    COORDENADA *naoVisitados = malloc(sizeof(COORDENADA) * length); // Aloca memória para o array de não visitados
       19:  113:    int cont = 0;
       64:  114:    for (int i = 0; i < l; i++)
        -:  115:    {
      156:  116:        for (int j = 0; j < c; j++)
        -:  117:        {
      111:  118:            if (visited[i][j] == 0) // Casa não visitada
        -:  119:            {
       58:  120:                COORDENADA pos = malloc(sizeof(struct Coordenada));
       58:  121:                pos->l = i;
       58:  122:                pos->c = j;
       58:  123:                naoVisitados[cont++] = pos;
        -:  124:            }
        -:  125:        }
        -:  126:    }
       19:  127:    return naoVisitados;
        -:  128:}
        -:  129:
        -:  130:// Algoritmo de busca em largura (BFS) para verificar se existe um caminho ortogonal entre todas as casas não riscadas.
       76:  131:int existeCaminhoOrtogonal(CQUEUE q, TABELA t, int **visited, int *count)
        -:  132:{
       76:  133:    int direcoes[4][2] = {
        -:  134:        {-1, 0}, // Cima
        -:  135:        {1, 0},  // Baixo
        -:  136:        {0, -1}, // Esquerda
        -:  137:        {0, 1}   // Direita
        -:  138:    };
        -:  139:
      342:  140:    while (q->tamanho > 0) // Enquanto houver elementos na fila
        -:  141:    {
      266:  142:        COORDENADA atual = NULL;
      266:  143:        deleteQueue(q, &atual); // Remove o elemento da frente da fila
        -:  144:
      266:  145:        visited[atual->l][atual->c] = 1; // Marca a casa atual como visitada
      266:  146:        (*count)++;
        -:  147:
      266:  148:        int numeroVizinhosValidos = 0;
      266:  149:        COORDENADA *vizinhos = malloc(4 * sizeof(COORDENADA)); // No máximo existem 4 vizinhos válidos
     1330:  150:        for (int i = 0; i < 4; i++)
        -:  151:        {
     1064:  152:            int linha = direcoes[i][0] + atual->l;
     1064:  153:            int coluna = direcoes[i][1] + atual->c;
        -:  154:
     1064:  155:            if (dentroDosLimites(t, linha, coluna) && visited[linha][coluna] == 0) // Verifica se o vizinho é válido
        -:  156:            {
      190:  157:                COORDENADA pos = malloc(sizeof(struct Coordenada));
      190:  158:                pos->l = linha;
      190:  159:                pos->c = coluna;
      190:  160:                vizinhos[numeroVizinhosValidos] = pos;
      190:  161:                visited[linha][coluna] = 1; // Marca o vizinho como visitado
      190:  162:                numeroVizinhosValidos++;
        -:  163:            }
        -:  164:        }
      266:  165:        insertQueue(q, vizinhos, numeroVizinhosValidos); // Insere os vizinhos na fila
      266:  166:        free(atual);
      266:  167:        free(vizinhos);
        -:  168:    }
        -:  169:
        -:  170:    // Verifica se todas as casas foram visitadas
       76:  171:    if (*count == t->c * t->l)
       61:  172:        return 1;
        -:  173:    return 0;
        -:  174:}
        -:  175:
        -:  176:// Função que escreve as restrições caso não exista um caminho ortogonal entre todas as casas não riscadas.
       15:  177:void escreveInexistenciaCaminho(bool *temRestricoes, bool escreve, int *contaRestricoes, TABELA t, int **visited, int colunaI, int linhaI, int count)
        -:  178:{
       15:  179:    *temRestricoes = true;
       15:  180:    if (escreve)
        -:  181:    {
    #####:  182:        printf("\n%s%s---- Restrição nº %d ----%s\n", HINT_COLOR, BOLD, *contaRestricoes + 1, RESET);
    #####:  183:        printf("Não existe um caminho ortogonal entre todas as casas que não estão riscadas\n");
        -:  184:    }
       15:  185:    (*contaRestricoes)++;
       15:  186:    int length = t->c * t->l - count;
       15:  187:    COORDENADA *naoVisitados = devolveNaoVisitados(visited, t->l, t->c, length);
       15:  188:    if (escreve)
    #####:  189:        printf("Por exemplo, começando da casa (%c%d) não existe um caminho ortogonal que passe nas casas:\n", colunaI + 'a', linhaI + 1);
       65:  190:    for (int i = 0; i < length; i++)
        -:  191:    {
       50:  192:        if (escreve)
    #####:  193:            printf("  - Coluna: %c, Linha: %d\n", naoVisitados[i]->c + 'a', naoVisitados[i]->l + 1);
       50:  194:        free(naoVisitados[i]);
        -:  195:    }
       15:  196:    free(naoVisitados);
       15:  197:}
        -:  198:
        -:  199:// Função principal que verifica se existe um caminho ortogonal entre todas as casas não riscadas.
        -:  200:// Caso não exista, escreve as restrições.
       72:  201:bool trataCaminhoOrtogonal(TABELA t, int *contaRestricoes, bool *temRestricoes, bool escreve)
        -:  202:{
       72:  203:    CQUEUE queue = malloc(sizeof(struct CQueue));
       72:  204:    initQueue(queue);
        -:  205:
       72:  206:    COORDENADA inicial = devolvePrimeiroNRiscado(t);
       72:  207:    if (inicial == NULL) // Se não há casas não riscadas, retorna true
        -:  208:    {
    #####:  209:        free(queue->list);
    #####:  210:        free(queue);
    #####:  211:        return true;
        -:  212:    }
        -:  213:
       72:  214:    int linhaI = inicial->l;
       72:  215:    int colunaI = inicial->c;
        -:  216:
       72:  217:    COORDENADA *primeiro = malloc(sizeof(COORDENADA)); // Adiciona a primeira coordenada à fila
       72:  218:    primeiro[0] = inicial;
       72:  219:    insertQueue(queue, primeiro, 1);
        -:  220:
       72:  221:    int count = 0;
       72:  222:    int **visited = initVisited(t, &count);
       72:  223:    if (!existeCaminhoOrtogonal(queue, t, visited, &count)) // Verifica se existe um caminho ortogonal
        -:  224:    {
       15:  225:        escreveInexistenciaCaminho(temRestricoes, escreve, contaRestricoes, t, visited, colunaI, linhaI, count);
        -:  226:    }
        -:  227:
       72:  228:    free(primeiro);
      236:  229:    for (int i = 0; i < t->l; i++)
      164:  230:        free(visited[i]);
       72:  231:    free(visited);
        -:  232:
       72:  233:    free(queue->list);
       72:  234:    free(queue);
        -:  235:
       72:  236:    return true;
        -:  237:}
