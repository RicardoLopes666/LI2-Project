        -:    0:Source:parte3/parte3.c
        -:    0:Graph:parte3/parte3.gcno
        -:    0:Data:parte3/parte3.gcda
        -:    0:Runs:11
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "../tipos.h"
        -:    4:#include "../parte2/parte2.h"
        -:    5:#include <ctype.h>
        -:    6:#include "../colors.h"
        -:    7:
        -:    8:// Função que dada uma tabela a percorre por ordem de linhas e colunas até encontrar o primeiro elemento que não estiver riscado, o qual vai ser utilizado para o bfs e devolve esse elemento como uma coordenada
      159:    9:COORDENADA devolvePrimeroNRiscado(TABELA t)
        -:   10:{
      159:   11:    int i = 0;
      200:   12:    while (i < (t->c * t->l) && t->tabela[i / t->c][i % t->c] == '#')
       41:   13:        i++;
      159:   14:    if (i >= t->c * t->l)
        -:   15:        return NULL;
      159:   16:    COORDENADA pos = malloc(sizeof(struct Coordenada));
      159:   17:    pos->l = i / t->c;
      159:   18:    pos->c = i % t->c;
      159:   19:    return pos;
        -:   20:}
        -:   21:
        -:   22:// Função que inicializa o array de visitados com 0 exceto nas casas que estão riscas (0 -> não visitado, 1 -> visitado)
      170:   23:int **initVisited(TABELA t, int *count) // Count conta o número de casas visitadas
        -:   24:{
      170:   25:    int **visited = malloc(sizeof(int *) * t->l);
      576:   26:    for (int i = 0; i < t->l; i++)
        -:   27:    {
      406:   28:        visited[i] = malloc(sizeof(int) * t->c);
     1416:   29:        for (int j = 0; j < t->c; j++)
     1010:   30:            if (t->tabela[i][j] == '#')
        -:   31:            {
      203:   32:                visited[i][j] = 1;
      203:   33:                (*count)++; // Atualiza o número de casas visitadas
        -:   34:            }
        -:   35:            else
      807:   36:                visited[i][j] = 0;
        -:   37:    }
      170:   38:    return visited;
        -:   39:}
        -:   40:
      181:   41:void initQueue(CQUEUE q)
        -:   42:{
      181:   43:    q->capacidade = 3;
      181:   44:    q->tamanho = 0;
      181:   45:    q->front = 0;
      181:   46:    q->list = malloc(sizeof(COORDENADA) * q->capacidade);
      181:   47:}
        -:   48:
        -:   49:// Função responsável por inserir um array de coordenadas na queue
      815:   50:int insertQueue(CQUEUE q, COORDENADA *coordenadas, int coordSize)
        -:   51:{
      815:   52:    if (coordSize < 1)
        -:   53:        return 1;
      514:   54:    int tam = q->tamanho + coordSize;
      514:   55:    if (tam >= q->capacidade)
        -:   56:    {
        -:   57:        int oldCapacity = q->capacidade;
       66:   58:        while (tam >= q->capacidade)
       33:   59:            q->capacidade = q->capacidade == 0 ? 1 : q->capacidade * 2; // aumenta a capacidade até ter espaço para os novos elementos
       33:   60:        COORDENADA *temp = realloc(q->list, sizeof(COORDENADA) * q->capacidade);
       33:   61:        if (temp == NULL)
        -:   62:        {
        -:   63:            return 0;
        -:   64:        }
       33:   65:        q->list = temp;
       33:   66:        int end = q->front + q->tamanho;
       33:   67:        if (end > oldCapacity)
    #####:   68:            for (int i = 0; i < end % oldCapacity; i++)
    #####:   69:                q->list[i + oldCapacity] = q->list[i]; // volta a colocar a queue direita
        -:   70:    }
     1181:   71:    for (int i = 0; i < coordSize; i++)
        -:   72:    {
      667:   73:        q->list[(q->front + q->tamanho) % q->capacidade] = coordenadas[i];
      667:   74:        q->tamanho++;
        -:   75:    }
        -:   76:    return 1;
        -:   77:}
        -:   78:
        -:   79:// Função que remove o elemento da frente da queue
      645:   80:void deleteQueue(CQUEUE q, COORDENADA *pos)
        -:   81:{
      645:   82:    if (q->tamanho == 0)
        -:   83:        return;
        -:   84:    // retira o elemento da frente, mas não o free — é mais tarde na existeCaminhoOrtogonal
      645:   85:    COORDENADA temp = q->list[q->front];
      645:   86:    *pos = temp;
      645:   87:    q->list[q->front] = NULL;
      645:   88:    q->front = (q->front + 1) % q->capacidade;
      645:   89:    q->tamanho--;
        -:   90:}
        -:   91:
        -:   92:// Função que dado uma lista de visitados devolve um array com as posições que não foram visitadas
       30:   93:COORDENADA *devolveNaoVisitados(int **visited, int l, int c, int length)
        -:   94:{
       30:   95:    COORDENADA *naoVisitados = malloc(sizeof(COORDENADA) * length);
       30:   96:    int cont = 0;
      101:   97:    for (int i = 0; i < l; i++)
        -:   98:    {
      246:   99:        for (int j = 0; j < c; j++)
        -:  100:        {
      175:  101:            if (visited[i][j] == 0)
        -:  102:            {
       85:  103:                COORDENADA pos = malloc(sizeof(struct Coordenada));
       85:  104:                pos->l = i;
       85:  105:                pos->c = j;
       85:  106:                naoVisitados[cont++] = pos;
        -:  107:            }
        -:  108:        }
        -:  109:    }
       30:  110:    return naoVisitados;
        -:  111:}
        -:  112:
        -:  113:// Algoritmo de procura em largura
      159:  114:int existeCaminhoOrtogonal(CQUEUE q, TABELA t, int **visited, int *count)
        -:  115:{
      159:  116:    int direcoes[4][2] = {
        -:  117:        {-1, 0}, // Cima
        -:  118:        {1, 0},  // Baixo
        -:  119:        {0, -1}, // Esquerda
        -:  120:        {0, 1}   // Direita
        -:  121:    };
      793:  122:    while (q->tamanho > 0)
        -:  123:    {
      634:  124:        COORDENADA atual = NULL;
      634:  125:        deleteQueue(q, &atual); // passa o endereço de 'atual' (COORDENADA*) -> e pegamos no elemento que esta na frente da fila
        -:  126:
      634:  127:        visited[atual->l][atual->c] = 1; // Visitamos a atual;
      634:  128:        (*count)++;
      634:  129:        int numeroVizinhosValidos = 0;
      634:  130:        COORDENADA *vizinhos = malloc(4 * sizeof(COORDENADA)); // no máximo existem 4 vizinhos válidos
     3170:  131:        for (int i = 0; i < 4; i++)
        -:  132:        {
     2536:  133:            int linha = direcoes[i][0] + atual->l;
     2536:  134:            int coluna = direcoes[i][1] + atual->c;
        -:  135:
     2536:  136:            if (dentroDosLimites(t, linha, coluna) && visited[linha][coluna] == 0)
        -:  137:            {
      475:  138:                COORDENADA pos = malloc(sizeof(struct Coordenada));
      475:  139:                pos->l = linha;
      475:  140:                pos->c = coluna;
      475:  141:                vizinhos[numeroVizinhosValidos] = pos;
      475:  142:                visited[linha][coluna] = 1; // Tenho que marcar aqui para que nas proximas iterações ja se saiba que esta já esta na queue não voltar a entrar
      475:  143:                numeroVizinhosValidos++;
        -:  144:            }
        -:  145:        }
      634:  146:        insertQueue(q, vizinhos, numeroVizinhosValidos); // já trata do caso de não ter qualquer elemento
      634:  147:        free(atual);
      634:  148:        free(vizinhos);
        -:  149:    }
      159:  150:    if (*count == t->c * t->l)
      129:  151:        return 1;
        -:  152:    return 0;
        -:  153:}
        -:  154:
       30:  155:void escreveInexistenciaCaminho(bool *temRestricoes, bool escreve, int *contaRestricoes, TABELA t, int **visited, int colunaI, int linhaI, int count)
        -:  156:{
       30:  157:    *temRestricoes = true;
       30:  158:    if (escreve)
        -:  159:    {
    #####:  160:        printf("\n%s%s---- Restrição nº %d ----%s\n", HINT_COLOR, BOLD, *contaRestricoes + 1, RESET);
    #####:  161:        printf("Não existe um caminho ortogonal entre todas as casas que não estão riscadas\n");
        -:  162:    }
       30:  163:    (*contaRestricoes)++;
       30:  164:    int length = t->c * t->l - count;
       30:  165:    COORDENADA *naoVisitados = devolveNaoVisitados(visited, t->l, t->c, length);
       30:  166:    if (escreve)
    #####:  167:        printf("Por exemplo, começando da casa (%c%d) não existe um caminho ortogonal que passe nas casas:\n", colunaI + 'a', linhaI + 1);
      115:  168:    for (int i = 0; i < length; i++)
        -:  169:    {
       85:  170:        if (escreve)
    #####:  171:            printf("  - Coluna: %c, Linha: %d\n", naoVisitados[i]->c + 'a', naoVisitados[i]->l + 1);
       85:  172:        free(naoVisitados[i]);
        -:  173:    }
       30:  174:    free(naoVisitados);
       30:  175:}
        -:  176:
      148:  177:bool trataCaminhoOrtogonal(TABELA t, int *contaRestricoes, bool *temRestricoes, bool escreve)
        -:  178:{
      148:  179:    CQUEUE queue = malloc(sizeof(struct CQueue));
      148:  180:    initQueue(queue);
        -:  181:
      148:  182:    COORDENADA inicial = devolvePrimeroNRiscado(t);
      148:  183:    if (inicial == NULL)
        -:  184:    {
    #####:  185:        free(queue->list);
    #####:  186:        free(queue);
    #####:  187:        return true;
        -:  188:    }
      148:  189:    int linhaI = inicial->l;
      148:  190:    int colunaI = inicial->c;
        -:  191:
      148:  192:    COORDENADA *primeiro = malloc(sizeof(COORDENADA)); // Array do com o primeiro elemento a queue já ter elementos antes de se chamar existeCaminhoOrtogonal
      148:  193:    primeiro[0] = inicial;
      148:  194:    insertQueue(queue, primeiro, 1);
        -:  195:
      148:  196:    int count = 0;
      148:  197:    int **visited = initVisited(t, &count);
      148:  198:    if (!existeCaminhoOrtogonal(queue, t, visited, &count))
        -:  199:    {
       30:  200:        escreveInexistenciaCaminho(temRestricoes, escreve, contaRestricoes, t, visited, colunaI, linhaI, count);
        -:  201:    }
        -:  202:
      148:  203:    free(primeiro);
      488:  204:    for (int i = 0; i < t->l; i++)
      340:  205:        free(visited[i]);
      148:  206:    free(visited);
        -:  207:
      148:  208:    free(queue->list);
      148:  209:    free(queue);
        -:  210:
      148:  211:    return true;
        -:  212:}
