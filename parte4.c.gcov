        -:    0:Source:parte4/parte4.c
        -:    0:Graph:parte4/parte4.gcno
        -:    0:Data:parte4/parte4.gcda
        -:    0:Runs:6
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <ctype.h>
        -:    4:#include "../tipos.h"
        -:    5:#include "../parte2/parte2.h" // Inclui a declaração de copiarTabela e dentroDosLimites
        -:    6:#include "../parte1/parte1.h"
        -:    7:#include "../parte3/parte3.h"
        -:    8:#include "../colors.h"
        -:    9:
        -:   10:// Função que deteta as casas que se riscadas impediam um caminho ortogonal entre casas e nesse caso pinta-as
       56:   11:void verificaSeQuebraCaminho(TABELA aux, int l, int c, bool *changed, bool escreve)
        -:   12:{
       56:   13:    char caracter = aux->tabela[l][c];
       56:   14:    aux->tabela[l][c] = '#';
       56:   15:    int contaRestricoes = 0;
       56:   16:    trataCaminhoOrtogonal(aux, &contaRestricoes, changed, false);
       56:   17:    if (contaRestricoes > 0)
        -:   18:    {
       16:   19:        aux->tabela[l][c] = toupper(caracter);
       16:   20:        if (escreve)
        6:   21:            printf("A pintar a célula %c%d de branco por isolar as restantes casas ao ser riscada.\n", c + 'a', l + 1);
       16:   22:        *changed = true;
        -:   23:    }
        -:   24:    else
       40:   25:        aux->tabela[l][c] = caracter;
       56:   26:}
        -:   27:
        -:   28:// ---- Codigo para o comando 'a' ----
        -:   29:// Função auxiliar para riscar letras repetidas na mesma linha ou coluna
       74:   30:void riscaLetrasRepetidas(TABELA t, TABELA aux, int i, int j, bool escreve, bool *changed)
        -:   31:{
       74:   32:    char letraMinuscula = tolower(t->tabela[i][j]);
        -:   33:
        -:   34:    // Verifica a linha
      264:   35:    for (int k = 0; k < t->c; k++)
        -:   36:    {
      190:   37:        if (k != j && t->tabela[i][k] == letraMinuscula)
        -:   38:        {
       22:   39:            if (escreve)
        6:   40:                printf("A riscar a célula %c%d com letra '%c' devido à repetição na linha.\n", 'a' + k, i + 1, t->tabela[i][k]);
       22:   41:            aux->tabela[i][k] = '#';
       22:   42:            *changed = true;
        -:   43:        }
        -:   44:    }
        -:   45:
        -:   46:    // Verifica a coluna
      264:   47:    for (int k = 0; k < t->l; k++)
        -:   48:    {
      190:   49:        if (k != i && t->tabela[k][j] == letraMinuscula)
        -:   50:        {
        1:   51:            if (escreve)
        1:   52:                printf("A riscar célula %c%d com letra '%c' devido à repetição na coluna.\n", 'a' + j, k + 1, t->tabela[k][j]);
        1:   53:            aux->tabela[k][j] = '#';
        1:   54:            *changed = true;
        -:   55:        }
        -:   56:    }
       74:   57:}
        -:   58:
        -:   59:// Função auxiliar para pintar vizinhos de casas riscadas
       50:   60:void pintaVizinhosDeRiscadas(TABELA t, TABELA aux, int i, int j, bool escreve, bool *changed)
        -:   61:{
       50:   62:    int direcoes[4][2] = {
        -:   63:        {-1, 0}, // Cima
        -:   64:        {1, 0},  // Baixo
        -:   65:        {0, -1}, // Esquerda
        -:   66:        {0, 1}   // Direita
        -:   67:    };
        -:   68:
      250:   69:    for (int d = 0; d < 4; d++)
        -:   70:    {
      200:   71:        int novaLinha = i + direcoes[d][0];
      200:   72:        int novaColuna = j + direcoes[d][1];
        -:   73:
      200:   74:        if (dentroDosLimites(t, novaLinha, novaColuna) && islower(t->tabela[novaLinha][novaColuna]))
        -:   75:        {
       28:   76:            if (escreve)
       24:   77:                printf("A pintar a célula %c%d de branco devido à casa riscada em %c%d.\n",
        -:   78:                       'a' + novaColuna, novaLinha + 1, 'a' + j, i + 1);
       28:   79:            aux->tabela[novaLinha][novaColuna] = toupper(t->tabela[novaLinha][novaColuna]);
       28:   80:            *changed = true;
        -:   81:        }
        -:   82:    }
       50:   83:}
        -:   84:
        -:   85:// Função principal 'a'
       54:   86:TABELA ajuda(TABELA t, bool escreve, bool *changed)
        -:   87:{
       54:   88:    TABELA aux = copiarTabela(t);
        -:   89:
      198:   90:    for (int i = 0; i < t->l; i++)
        -:   91:    {
      540:   92:        for (int j = 0; j < t->c; j++)
        -:   93:        {
      396:   94:            if (isupper(t->tabela[i][j]))
        -:   95:            {
       68:   96:                riscaLetrasRepetidas(t, aux, i, j, escreve, changed);
        -:   97:            }
        -:   98:
      396:   99:            if (t->tabela[i][j] == '#')
        -:  100:            {
       44:  101:                pintaVizinhosDeRiscadas(t, aux, i, j, escreve, changed);
        -:  102:            }
        -:  103:
      396:  104:            if (islower(t->tabela[i][j]))
        -:  105:            {
       44:  106:                verificaSeQuebraCaminho(aux, i, j, changed, escreve);
        -:  107:            }
        -:  108:        }
        -:  109:    }
        -:  110:
       54:  111:    return aux;
        -:  112:}
        -:  113:
        -:  114:// Código do comando A
        -:  115:// Aplica o comando "a" até não haver alterações. Retorna > 0 caso haja mundanças e 0 caso não haja
       34:  116:int aplicaA(TABELA *aux)
        -:  117:{
       34:  118:    int mudancas = 0;
       34:  119:    bool changed = true;
       88:  120:    while (changed)
        -:  121:    {
       54:  122:        changed = false;
       54:  123:        TABELA temp = *aux;
       54:  124:        *aux = ajuda(temp, false, &changed);
       54:  125:        if (changed == true)
       20:  126:            mudancas++;
       54:  127:        freeTabela(temp);
        -:  128:    }
       34:  129:    return mudancas;
        -:  130:}
        -:  131:
       12:  132:void comandoA(TABELA *aux, bool *continuar)
        -:  133:{
       12:  134:    int mudou = aplicaA(aux);
       12:  135:    if (!mudou)
        -:  136:    {
        6:  137:        printf("O tabuleiro não sofreu alterações.\n");
        6:  138:        *continuar = false; // Coloca -se a falso para não se fazer uma cópia do tabuleiro neste caso
        -:  139:    }
        -:  140:    else
        6:  141:        printf("%sTabuleiro alterado.%s\n", GREEN, RESET);
       12:  142:}
        -:  143:
        -:  144:// --- Codigo para o comando R ---
        -:  145:
        -:  146:// Função que detatas na linhas os grupos do tipo XX_ X e risca o que esta isolado
       12:  147:void trataAA_A_NasLinhas(TABELA aux)
        -:  148:{
       42:  149:    for (int i = 0; i < aux->l; i++)
        -:  150:    {
       78:  151:        for (int j = 0; j < aux->c - 1; j++)
        -:  152:        {
       48:  153:            if (tolower(aux->tabela[i][j]) == tolower(aux->tabela[i][j + 1]))
        -:  154:            {
       84:  155:                for (int k = 0; k < aux->c; k++)
        -:  156:                {
       62:  157:                    if (k != j && k != j + 1 && tolower(aux->tabela[i][j]) == tolower(aux->tabela[i][k]))
        -:  158:                    {
       18:  159:                        aux->tabela[i][k] = '#';
        -:  160:                    }
        -:  161:                }
        -:  162:            }
        -:  163:        }
        -:  164:    }
       12:  165:}
        -:  166:
        -:  167:// Função que detatas na colunas os grupos do tipo XX_ X e risca o que esta isolado
       12:  168:void trataAA_A_NasColunas(TABELA aux)
        -:  169:{
       42:  170:    for (int j = 0; j < aux->c; j++)
        -:  171:    {
       78:  172:        for (int i = 0; i < aux->l - 1; i++)
        -:  173:        {
       48:  174:            if (tolower(aux->tabela[i][j]) == tolower(aux->tabela[i + 1][j]))
        -:  175:            {
       84:  176:                for (int k = 0; k < aux->l; k++)
        -:  177:                {
       62:  178:                    if (k != i && k != i + 1 && tolower(aux->tabela[i][j]) == tolower(aux->tabela[k][j]))
        -:  179:                    {
       18:  180:                        aux->tabela[k][j] = '#';
        -:  181:                    }
        -:  182:                }
        -:  183:            }
        -:  184:        }
        -:  185:    }
       12:  186:}
        -:  187:
        -:  188:// Função que identifica grupos do tipo xx .... x e trata de riscar o x isolado
        6:  189:void risca_AA_A(TABELA aux)
        -:  190:{
        6:  191:    trataAA_A_NasColunas(aux);
        6:  192:    trataAA_A_NasLinhas(aux);
        6:  193:}
        -:  194:
        -:  195:// Detetar grupos ABA nas linhas
       12:  196:void trataABA_linhas(TABELA aux)
        -:  197:{
       42:  198:    for (int i = 0; i < aux->l; i++)
        -:  199:    {
       48:  200:        for (int j = 0; j < aux->c - 2; j++)
        -:  201:        {
       18:  202:            if (aux->tabela[i][j] != '#' && aux->tabela[i][j] == aux->tabela[i][j + 2] && aux->tabela[i][j + 1] != '#')
        -:  203:            {
        -:  204:                // Pintar de branco o elemento do meio
       18:  205:                aux->tabela[i][j + 1] = toupper(aux->tabela[i][j + 1]);
        -:  206:            }
        -:  207:        }
        -:  208:    }
       12:  209:}
        -:  210:
        -:  211:// Detetar grupos ABA nas colunas
       12:  212:void trataABA_colunas(TABELA aux)
        -:  213:{
       42:  214:    for (int j = 0; j < aux->c; j++)
        -:  215:    {
       48:  216:        for (int i = 0; i < aux->l - 2; i++)
        -:  217:        {
      18*:  218:            if (aux->tabela[i][j] != '#' && aux->tabela[i][j] == aux->tabela[i + 2][j] && aux->tabela[i + 1][j] != '#')
        -:  219:            {
        -:  220:                // Pintar de branco o elemento do meio
    #####:  221:                aux->tabela[i + 1][j] = toupper(aux->tabela[i + 1][j]);
        -:  222:            }
        -:  223:        }
        -:  224:    }
       12:  225:}
        -:  226:
        -:  227:// Detetar grupos ABA
       12:  228:void riscaABA(TABELA aux)
        -:  229:{
       12:  230:    trataABA_colunas(aux);
       12:  231:    trataABA_linhas(aux);
       12:  232:}
        -:  233:
       26:  234:int existemMinusculas(TABELA t)
        -:  235:{
       70:  236:    for (int i = 0; i < t->l; i++)
        -:  237:    {
      166:  238:        for (int j = 0; j < t->c; j++)
      122:  239:            if (islower(t->tabela[i][j]))
        -:  240:                return 1;
        -:  241:    }
        -:  242:    return 0;
        -:  243:}
        -:  244:
        -:  245:// Verificar se o jogo está completo (sem minúsculas e sem erros)
       26:  246:int jogoResolvido(TABELA aux)
        -:  247:{
        -:  248:    // verificar se existem minúsculas ou regras violadas
       26:  249:    if (existemMinusculas(aux) || verificaRestricoes(aux, false))
       10:  250:        return 0;
        -:  251:    return 1;
        -:  252:}
        -:  253:
        -:  254:// Função que tenta pintar para as duas casas que tem iguais e ve se em alguns dos casos se obtem o jogo resolvido ou ent alguma restrição
        4:  255:void tentaRiscarColunas(int l, int c1, int c2, TABELA *t, bool *continuar)
        -:  256:{
        -:  257:
        4:  258:    int cs[2] = {c1, c2};
        4:  259:    int keepGoing = 1; // variavel utilizada para parar o loop em caso de o tabuleiro estar resolvido
        8:  260:    for (int i = 0; keepGoing && i < 2; i++)
        -:  261:    {
        4:  262:        TABELA tentativa = copiarTabela(*t);
        4:  263:        int linha = l;
        4:  264:        int coluna = cs[i];
        4:  265:        char letra = (*t)->tabela[linha][coluna];
        4:  266:        tentativa->tabela[linha][coluna] = toupper(letra);
        4:  267:        aplicaA(&tentativa);
        4:  268:        if (jogoResolvido(tentativa))
        -:  269:        {
        4:  270:            *continuar = false;
        4:  271:            keepGoing = 0;
        4:  272:            TABELA temp = *t;
        4:  273:            *t = copiarTabela(tentativa);
        4:  274:            freeTabela(temp);
        -:  275:        }
    #####:  276:        else if (verificaRestricoes(tentativa, false)) // Caso assim existam restrições eu mudo ja na tabela original porque sei que tem de ser da outra forma
        -:  277:        {
    #####:  278:            keepGoing = 0;
    #####:  279:            (*t)->tabela[linha][coluna] = '#';
    #####:  280:            (*t)->tabela[linha][i == 0 ? c2 : c1] = toupper(letra);
        -:  281:        }
        4:  282:        freeTabela(tentativa);
        -:  283:    }
        4:  284:}
        -:  285:
        -:  286:// Função que vai a cada linha e verifica elementos iguas minusculos e tenta pintar um deles para ver se se consegue chegar à resposta
        -:  287:// Devolve true se a resposta for encontrada e false caso contrario
        4:  288:bool tentaColunas(TABELA *t)
        -:  289:{
        4:  290:    bool continuar = true;
        8:  291:    for (int i = 0; continuar && i < (*t)->l; i++)
        -:  292:    {
        8:  293:        for (int j = 0; continuar && j < (*t)->c; j++)
        -:  294:        {
        4:  295:            if (islower((*t)->tabela[i][j]))
        -:  296:            {
       12:  297:                for (int k = 0; continuar && k < (*t)->c; k++)
        -:  298:                {
        8:  299:                    if (k != j && (*t)->tabela[i][k] == (*t)->tabela[i][j])
        -:  300:                    {
        4:  301:                        tentaRiscarColunas(i, j, k, t, &continuar);
        4:  302:                        if (continuar)
    #####:  303:                            aplicaA(t);
        4:  304:                        if (jogoResolvido(*t))
        4:  305:                            continuar = false;
        -:  306:                    }
        -:  307:                }
        -:  308:            }
        -:  309:        }
        -:  310:    }
        4:  311:    return (!continuar);
        -:  312:}
        -:  313:
        -:  314:// Função que tenta pintar para as duas casas que tem iguais e ve se em alguns dos casos se obtem o jogo resolvido ou ent alguma restrição
    #####:  315:void tentaRiscarLinhas(int c, int l1, int l2, TABELA *t, bool *continuar)
        -:  316:{
        -:  317:
    #####:  318:    int ls[2] = {l1, l2};
    #####:  319:    int keepGoing = 1;
    #####:  320:    for (int i = 0; keepGoing && i < 2; i++)
        -:  321:    {
    #####:  322:        TABELA tentativa = copiarTabela(*t);
    #####:  323:        int linha = ls[i];
    #####:  324:        int coluna = c;
    #####:  325:        char letra = (*t)->tabela[linha][coluna];
    #####:  326:        tentativa->tabela[linha][coluna] = toupper(letra);
    #####:  327:        aplicaA(&tentativa);
    #####:  328:        if (jogoResolvido(tentativa))
        -:  329:        {
    #####:  330:            *continuar = false;
    #####:  331:            keepGoing = 0;
    #####:  332:            TABELA temp = *t;
    #####:  333:            *t = copiarTabela(tentativa);
    #####:  334:            freeTabela(temp);
        -:  335:        }
    #####:  336:        else if (verificaRestricoes(tentativa, false)) // Caso assim existam restrições eu mudo ja na tabela original porque sei que tem de ser da outra forma
        -:  337:        {
    #####:  338:            keepGoing = 0;
    #####:  339:            (*t)->tabela[linha][coluna] = '#';
    #####:  340:            (*t)->tabela[i == 0 ? l2 : l1][coluna] = toupper(letra); // uso letra porque ambas as posições tem a mesma letra minuscula la
        -:  341:        }
    #####:  342:        freeTabela(tentativa);
        -:  343:    }
    #####:  344:}
        -:  345:
        -:  346:// Função que vai a cada coluna e verifica elementos iguas minusculos e tenta pintar um deles para ver se se consegue chegar à resposta
        -:  347:// Devolve true se a resposta for encontrada e false caso contrario
    #####:  348:bool tentaLinhas(TABELA *t)
        -:  349:{
    #####:  350:    bool continuar = true;
    #####:  351:    for (int i = 0; continuar && i < (*t)->l; i++)
        -:  352:    {
    #####:  353:        for (int j = 0; continuar && j < (*t)->c; j++)
        -:  354:        {
    #####:  355:            if (islower((*t)->tabela[j][i]))
        -:  356:            {
    #####:  357:                for (int k = 0; continuar && k < (*t)->l; k++)
        -:  358:                {
    #####:  359:                    if (k != j && (*t)->tabela[k][i] == (*t)->tabela[j][i])
        -:  360:                    {
    #####:  361:                        tentaRiscarLinhas(i, j, k, t, &continuar);
    #####:  362:                        if (continuar)
    #####:  363:                            aplicaA(t);
    #####:  364:                        if (jogoResolvido(*t))
    #####:  365:                            continuar = false;
        -:  366:                    }
        -:  367:                }
        -:  368:            }
        -:  369:        }
        -:  370:    }
    #####:  371:    return (!continuar);
        -:  372:}
        -:  373:
        -:  374:// Função que recebe a tabela inicial de quando o jogo foi carregado e tenta resolver o jogo -> Comando R
        -:  375:// Coloca ainda o aux a null null e o continuar a false caso não seja possivel resolver o tabuleiro
        6:  376:TABELA resolve(TABELA t)
        -:  377:{
        6:  378:    TABELA aux = copiarTabela(t);
        -:  379:
        -:  380:    // Funções que riscam as casas que se tem a certeza que tem de ser riscadas
        6:  381:    riscaABA(aux);
        6:  382:    risca_AA_A(aux);
        -:  383:
        -:  384:    // Aplica-se o comando 'a' repetidamente até ele não fazer mais alterações
        6:  385:    aplicaA(&aux);
       6*:  386:    if (!jogoResolvido(aux) && !tentaColunas(&aux) && !tentaLinhas(&aux))
        -:  387:    {
    #####:  388:        freeTabela(aux);
    #####:  389:        return NULL;
        -:  390:    }
        6:  391:    return aux;
        -:  392:}
