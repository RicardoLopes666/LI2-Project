        -:    0:Source:parte4/parte4.c
        -:    0:Graph:parte4/parte4.gcno
        -:    0:Data:parte4/parte4.gcda
        -:    0:Runs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <ctype.h>
        -:    4:#include "../tipos.h"
        -:    5:#include "../parte2/parte2.h" // Inclui a declaração de copiarTabela e dentroDosLimites
        -:    6:#include "../parte1/parte1.h"
        -:    7:#include "../parte3/parte3.h"
        -:    8:#include "../colors.h"
        -:    9:
        -:   10:// Função que deteta as casas que se riscadas impediam um caminho ortogonal entre casas e nesse caso pinta-as
       16:   11:void verificaSeQuebraCaminho(TABELA aux, int l, int c, bool *changed, bool escreve)
        -:   12:{
       16:   13:    char caracter = aux->tabela[l][c];
       16:   14:    aux->tabela[l][c] = '#';
       16:   15:    int contaRestricoes = 0;
       16:   16:    trataCaminhoOrtogonal(aux, &contaRestricoes, changed, false);
       16:   17:    if (contaRestricoes > 0)
        -:   18:    {
        2:   19:        aux->tabela[l][c] = toupper(caracter);
        2:   20:        if (escreve)
        1:   21:            printf("A pintar a célula %c%d de branco por isolar as restantes casas ao ser riscada.\n", c + 'a', l + 1);
        2:   22:        *changed = true;
        -:   23:    }
        -:   24:    else
       14:   25:        aux->tabela[l][c] = caracter;
       16:   26:}
        -:   27:
        -:   28:// ---- Codigo para o comando 'a' ----
        -:   29:// Função auxiliar para riscar letras repetidas na mesma linha ou coluna
       26:   30:void riscaLetrasRepetidas(TABELA t, TABELA aux, int i, int j, bool escreve, bool *changed)
        -:   31:{
       26:   32:    char letraMinuscula = tolower(t->tabela[i][j]);
        -:   33:
        -:   34:    // Verifica a linha
       76:   35:    for (int k = 0; k < t->c; k++)
        -:   36:    {
       50:   37:        if (k != j && t->tabela[i][k] == letraMinuscula)
        -:   38:        {
        4:   39:            if (escreve)
        1:   40:                printf("A riscar a célula %c%d com letra '%c' devido à repetição na linha.\n", 'a' + k, i + 1, t->tabela[i][k]);
        4:   41:            aux->tabela[i][k] = '#';
        4:   42:            *changed = true;
        -:   43:        }
        -:   44:    }
        -:   45:
        -:   46:    // Verifica a coluna
       76:   47:    for (int k = 0; k < t->l; k++)
        -:   48:    {
       50:   49:        if (k != i && t->tabela[k][j] == letraMinuscula)
        -:   50:        {
        4:   51:            if (escreve)
        1:   52:                printf("A riscar célula %c%d com letra '%c' devido à repetição na coluna.\n", 'a' + j, k + 1, t->tabela[k][j]);
        4:   53:            aux->tabela[k][j] = '#';
        4:   54:            *changed = true;
        -:   55:        }
        -:   56:    }
       26:   57:}
        -:   58:
        -:   59:// Função auxiliar para pintar vizinhos de casas riscadas
       13:   60:void pintaVizinhosDeRiscadas(TABELA t, TABELA aux, int i, int j, bool escreve, bool *changed)
        -:   61:{
       13:   62:    int direcoes[4][2] = {
        -:   63:        {-1, 0}, // Cima
        -:   64:        {1, 0},  // Baixo
        -:   65:        {0, -1}, // Esquerda
        -:   66:        {0, 1}   // Direita
        -:   67:    };
        -:   68:
       65:   69:    for (int d = 0; d < 4; d++)
        -:   70:    {
       52:   71:        int novaLinha = i + direcoes[d][0];
       52:   72:        int novaColuna = j + direcoes[d][1];
        -:   73:
       52:   74:        if (dentroDosLimites(t, novaLinha, novaColuna) && islower(t->tabela[novaLinha][novaColuna]))
        -:   75:        {
        6:   76:            if (escreve)
        4:   77:                printf("A pintar a célula %c%d de branco devido à casa riscada em %c%d.\n",
        -:   78:                       'a' + novaColuna, novaLinha + 1, 'a' + j, i + 1);
        6:   79:            aux->tabela[novaLinha][novaColuna] = toupper(t->tabela[novaLinha][novaColuna]);
        6:   80:            *changed = true;
        -:   81:        }
        -:   82:    }
       13:   83:}
        -:   84:
        -:   85:// Função principal 'a'
       18:   86:TABELA ajuda(TABELA t, bool escreve, bool *changed)
        -:   87:{
       18:   88:    TABELA aux = copiarTabela(t);
        -:   89:
       49:   90:    for (int i = 0; i < t->l; i++)
        -:   91:    {
       86:   92:        for (int j = 0; j < t->c; j++)
        -:   93:        {
       55:   94:            if (isupper(t->tabela[i][j]))
        -:   95:            {
       25:   96:                riscaLetrasRepetidas(t, aux, i, j, escreve, changed);
        -:   97:            }
        -:   98:
       55:   99:            if (t->tabela[i][j] == '#')
        -:  100:            {
       12:  101:                pintaVizinhosDeRiscadas(t, aux, i, j, escreve, changed);
        -:  102:            }
        -:  103:
       55:  104:            if (islower(t->tabela[i][j]))
        -:  105:            {
       14:  106:                verificaSeQuebraCaminho(aux, i, j, changed, escreve);
        -:  107:            }
        -:  108:        }
        -:  109:    }
        -:  110:
       18:  111:    return aux;
        -:  112:}
        -:  113:
        -:  114:// Código do comando A
        -:  115:// Aplica o comando "a" até não haver alterações. Retorna > 0 caso haja mundanças e 0 caso não haja
       12:  116:int aplicaA(TABELA *aux)
        -:  117:{
       12:  118:    int mudancas = 0;
       12:  119:    bool changed = true;
       30:  120:    while (changed)
        -:  121:    {
       18:  122:        changed = false;
       18:  123:        TABELA temp = *aux;
       18:  124:        *aux = ajuda(temp, false, &changed);
       18:  125:        if (changed == true)
        6:  126:            mudancas++;
       18:  127:        freeTabela(temp);
        -:  128:    }
       12:  129:    return mudancas;
        -:  130:}
        -:  131:
        2:  132:void comandoA(TABELA *aux, bool *continuar)
        -:  133:{
        2:  134:    int mudou = aplicaA(aux);
        2:  135:    if (!mudou)
        -:  136:    {
        1:  137:        printf("O tabuleiro não sofreu alterações.\n");
        1:  138:        *continuar = false; // Coloca -se a falso para não se fazer uma cópia do tabuleiro neste caso
        -:  139:    }
        -:  140:    else
        1:  141:        printf("%sTabuleiro alterado.%s\n", GREEN, RESET);
        2:  142:}
        -:  143:
        -:  144:// --- Codigo para o comando R ---
        -:  145:
        -:  146:// Função que detatas na linhas os grupos do tipo XX_ X e risca o que esta isolado
        5:  147:void trataAA_A_NasLinhas(TABELA aux)
        -:  148:{
       13:  149:    for (int i = 0; i < aux->l; i++)
        -:  150:    {
       16:  151:        for (int j = 0; j < aux->c - 1; j++)
        -:  152:        {
        8:  153:            if (tolower(aux->tabela[i][j]) == tolower(aux->tabela[i][j + 1]))
        -:  154:            {
       12:  155:                for (int k = 0; k < aux->c; k++)
        -:  156:                {
        9:  157:                    if (k != j && k != j + 1 && tolower(aux->tabela[i][j]) == tolower(aux->tabela[i][k]))
        -:  158:                    {
        3:  159:                        aux->tabela[i][k] = '#';
        -:  160:                    }
        -:  161:                }
        -:  162:            }
        -:  163:        }
        -:  164:    }
        5:  165:}
        -:  166:
        -:  167:// Função que detatas na colunas os grupos do tipo XX_ X e risca o que esta isolado
        5:  168:void trataAA_A_NasColunas(TABELA aux)
        -:  169:{
       13:  170:    for (int j = 0; j < aux->c; j++)
        -:  171:    {
       16:  172:        for (int i = 0; i < aux->l - 1; i++)
        -:  173:        {
        8:  174:            if (tolower(aux->tabela[i][j]) == tolower(aux->tabela[i + 1][j]))
        -:  175:            {
       12:  176:                for (int k = 0; k < aux->l; k++)
        -:  177:                {
        9:  178:                    if (k != i && k != i + 1 && tolower(aux->tabela[i][j]) == tolower(aux->tabela[k][j]))
        -:  179:                    {
        3:  180:                        aux->tabela[k][j] = '#';
        -:  181:                    }
        -:  182:                }
        -:  183:            }
        -:  184:        }
        -:  185:    }
        5:  186:}
        -:  187:
        -:  188:// Função que identifica grupos do tipo xx .... x e trata de riscar o x isolado
        4:  189:void risca_AA_A(TABELA aux)
        -:  190:{
        4:  191:    trataAA_A_NasColunas(aux);
        4:  192:    trataAA_A_NasLinhas(aux);
        4:  193:}
        -:  194:
        -:  195:// Detetar grupos ABA nas linhas
        6:  196:void trataABA_linhas(TABELA aux)
        -:  197:{
       17:  198:    for (int i = 0; i < aux->l; i++)
        -:  199:    {
       17:  200:        for (int j = 0; j < aux->c - 2; j++)
        -:  201:        {
        6:  202:            if (aux->tabela[i][j] != '#' && aux->tabela[i][j] == aux->tabela[i][j + 2] && aux->tabela[i][j + 1] != '#')
        -:  203:            {
        -:  204:                // Pintar de branco o elemento do meio
        6:  205:                aux->tabela[i][j + 1] = toupper(aux->tabela[i][j + 1]);
        -:  206:            }
        -:  207:        }
        -:  208:    }
        6:  209:}
        -:  210:
        -:  211:// Detetar grupos ABA nas colunas
        6:  212:void trataABA_colunas(TABELA aux)
        -:  213:{
       17:  214:    for (int j = 0; j < aux->c; j++)
        -:  215:    {
       17:  216:        for (int i = 0; i < aux->l - 2; i++)
        -:  217:        {
        6:  218:            if (aux->tabela[i][j] != '#' && aux->tabela[i][j] == aux->tabela[i + 2][j] && aux->tabela[i + 1][j] != '#')
        -:  219:            {
        -:  220:                // Pintar de branco o elemento do meio
        3:  221:                aux->tabela[i + 1][j] = toupper(aux->tabela[i + 1][j]);
        -:  222:            }
        -:  223:        }
        -:  224:    }
        6:  225:}
        -:  226:
        -:  227:// Detetar grupos ABA
        5:  228:void riscaABA(TABELA aux)
        -:  229:{
        5:  230:    trataABA_colunas(aux);
        5:  231:    trataABA_linhas(aux);
        5:  232:}
        -:  233:
       15:  234:int existemMinusculas(TABELA t)
        -:  235:{
       32:  236:    for (int i = 0; i < t->l; i++)
        -:  237:    {
       52:  238:        for (int j = 0; j < t->c; j++)
       35:  239:            if (islower(t->tabela[i][j]))
        -:  240:                return 1;
        -:  241:    }
        -:  242:    return 0;
        -:  243:}
        -:  244:
        -:  245:// Verificar se o jogo está completo (sem minúsculas e sem erros)
       12:  246:int jogoResolvido(TABELA aux)
        -:  247:{
        -:  248:    // verificar se existem minúsculas ou regras violadas
       12:  249:    if (existemMinusculas(aux) || verificaRestricoes(aux, false))
        4:  250:        return 0;
        -:  251:    return 1;
        -:  252:}
        -:  253:
        -:  254:// Função que tenta pintar para as duas casas que tem iguais e ve se em alguns dos casos se obtem o jogo resolvido ou ent alguma restrição
        2:  255:void tentaRiscarColunas(int l, int c1, int c2, TABELA *t, bool *continuar)
        -:  256:{
        -:  257:
        2:  258:    int cs[2] = {c1, c2};
        2:  259:    int keepGoing = 1; // variavel utilizada para parar o loop em caso de o tabuleiro estar resolvido
        4:  260:    for (int i = 0; keepGoing && i < 2; i++)
        -:  261:    {
        2:  262:        TABELA tentativa = copiarTabela(*t);
        2:  263:        int linha = l;
        2:  264:        int coluna = cs[i];
        2:  265:        char letra = (*t)->tabela[linha][coluna];
        2:  266:        tentativa->tabela[linha][coluna] = toupper(letra);
        2:  267:        aplicaA(&tentativa);
        2:  268:        if (jogoResolvido(tentativa))
        -:  269:        {
        2:  270:            *continuar = false;
        2:  271:            keepGoing = 0;
        2:  272:            TABELA temp = *t;
        2:  273:            *t = copiarTabela(tentativa);
        2:  274:            freeTabela(temp);
        -:  275:        }
    #####:  276:        else if (verificaRestricoes(tentativa, false)) // Caso assim existam restrições eu mudo ja na tabela original porque sei que tem de ser da outra forma
        -:  277:        {
    #####:  278:            keepGoing = 0;
    #####:  279:            (*t)->tabela[linha][coluna] = '#';
    #####:  280:            (*t)->tabela[linha][i == 0 ? c2 : c1] = toupper(letra);
        -:  281:        }
        2:  282:        freeTabela(tentativa);
        -:  283:    }
        2:  284:}
        -:  285:
        -:  286:// Função auxiliar que tenta riscar e verifica se o jogo fica resolvido
        1:  287:void tentaColunasAux(int i, int j, int k, TABELA *t, bool *continuar)
        -:  288:{
        1:  289:    tentaRiscarColunas(i, j, k, t, continuar);
        1:  290:    if (*continuar)
    #####:  291:        aplicaA(t);
        1:  292:    if (jogoResolvido(*t))
        1:  293:        *continuar = false;
        1:  294:}
        -:  295:
        -:  296:// Função que vai a cada linha e verifica elementos iguas minusculos e tenta pintar um deles para ver se se consegue chegar à resposta
        -:  297:// Devolve true se a resposta for encontrada e false caso contrario
        4:  298:bool tentaColunas(TABELA *t)
        -:  299:{
        4:  300:    bool continuar = true;
        9:  301:    for (int i = 0; continuar && i < (*t)->l; i++)
        -:  302:    {
       12:  303:        for (int j = 0; continuar && j < (*t)->c; j++)
        -:  304:        {
        7:  305:            if (islower((*t)->tabela[i][j]))
        -:  306:            {
       13:  307:                for (int k = 0; continuar && k < (*t)->c; k++)
        -:  308:                {
        8:  309:                    if (k != j && (*t)->tabela[i][k] == (*t)->tabela[i][j])
        1:  310:                        tentaColunasAux(i, j, k, t, &continuar);
        -:  311:                }
        -:  312:            }
        -:  313:        }
        -:  314:    }
        4:  315:    return (!continuar);
        -:  316:}
        -:  317:
        -:  318:// Função que tenta pintar para as duas casas que tem iguais e ve se em alguns dos casos se obtem o jogo resolvido ou ent alguma restrição
        2:  319:void tentaRiscarLinhas(int c, int l1, int l2, TABELA *t, bool *continuar)
        -:  320:{
        -:  321:
        2:  322:    int ls[2] = {l1, l2};
        2:  323:    int keepGoing = 1;
        4:  324:    for (int i = 0; keepGoing && i < 2; i++)
        -:  325:    {
        2:  326:        TABELA tentativa = copiarTabela(*t);
        2:  327:        int linha = ls[i];
        2:  328:        int coluna = c;
        2:  329:        char letra = (*t)->tabela[linha][coluna];
        2:  330:        tentativa->tabela[linha][coluna] = toupper(letra);
        2:  331:        aplicaA(&tentativa);
        2:  332:        if (jogoResolvido(tentativa))
        -:  333:        {
        2:  334:            *continuar = false;
        2:  335:            keepGoing = 0;
        2:  336:            TABELA temp = *t;
        2:  337:            *t = copiarTabela(tentativa);
        2:  338:            freeTabela(temp);
        -:  339:        }
    #####:  340:        else if (verificaRestricoes(tentativa, false)) // Caso assim existam restrições eu mudo ja na tabela original porque sei que tem de ser da outra forma
        -:  341:        {
    #####:  342:            keepGoing = 0;
    #####:  343:            (*t)->tabela[linha][coluna] = '#';
    #####:  344:            (*t)->tabela[i == 0 ? l2 : l1][coluna] = toupper(letra); // uso letra porque ambas as posições tem a mesma letra minuscula la
        -:  345:        }
        2:  346:        freeTabela(tentativa);
        -:  347:    }
        2:  348:}
        -:  349:
        -:  350:// Função auxiliar que tenta riscar e verifica se o jogo fica resolvido
        1:  351:void tentaLinhasAux(int i, int j, int k, TABELA *t, bool *continuar)
        -:  352:{
        1:  353:    tentaRiscarLinhas(i, j, k, t, continuar);
        1:  354:    if (*continuar)
    #####:  355:        aplicaA(t);
        1:  356:    if (jogoResolvido(*t))
        1:  357:        *continuar = false;
        1:  358:}
        -:  359:
        -:  360:// Função que vai a cada coluna e verifica elementos iguas minusculos e tenta pintar um deles para ver se se consegue chegar à resposta
        -:  361:// Devolve true se a resposta for encontrada e false caso contrario
        4:  362:bool tentaLinhas(TABELA *t)
        -:  363:{
        4:  364:    bool continuar = true;
        9:  365:    for (int i = 0; continuar && i < (*t)->l; i++)
        -:  366:    {
       12:  367:        for (int j = 0; continuar && j < (*t)->c; j++)
        -:  368:        {
        7:  369:            if (islower((*t)->tabela[j][i]))
        -:  370:            {
       13:  371:                for (int k = 0; continuar && k < (*t)->l; k++)
        -:  372:                {
        8:  373:                    if (k != j && (*t)->tabela[k][i] == (*t)->tabela[j][i])
        -:  374:                    {
        1:  375:                        tentaLinhasAux(i, j, k, t, &continuar);
        -:  376:                    }
        -:  377:                }
        -:  378:            }
        -:  379:        }
        -:  380:    }
        4:  381:    return (!continuar);
        -:  382:}
        -:  383:
        -:  384:// Função que recebe a tabela inicial de quando o jogo foi carregado e tenta resolver o jogo -> Comando R
        -:  385:// Coloca ainda o aux a null null e o continuar a false caso não seja possivel resolver o tabuleiro
        4:  386:TABELA resolve(TABELA t)
        -:  387:{
        4:  388:    TABELA aux = copiarTabela(t);
        -:  389:
        -:  390:    // Funções que riscam as casas que se tem a certeza que tem de ser riscadas
        4:  391:    riscaABA(aux);
        4:  392:    risca_AA_A(aux);
        -:  393:
        -:  394:    // Aplica-se o comando 'a' repetidamente até ele não fazer mais alterações
        4:  395:    aplicaA(&aux);
        4:  396:    if (!jogoResolvido(aux) && !tentaColunas(&aux) && !tentaLinhas(&aux))
        -:  397:    {
        3:  398:        freeTabela(aux);
        3:  399:        return NULL;
        -:  400:    }
        1:  401:    return aux;
        -:  402:}
