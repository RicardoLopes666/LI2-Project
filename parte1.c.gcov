        -:    0:Source:parte1/parte1.c
        -:    0:Graph:testes-parte1.gcno
        -:    0:Data:testes-parte1.gcda
        -:    0:Runs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdbool.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <ctype.h> // Para toupper
        -:    7:#define LINE_SIZE 1024
        -:    8:
        -:    9:// Struct para controlar o estado do programa (se ele deve continuar ou parar)
        -:   10:typedef struct estado
        -:   11:{
        -:   12:    bool looping;
        -:   13:} ESTADO;
        -:   14:
        -:   15:// Struct que representa o tabuleiro
        -:   16:typedef struct Tabela
        -:   17:{
        -:   18:    int l;         // Número de linhas
        -:   19:    int c;         // Número de colunas
        -:   20:    char **tabela; // Ponteiro para o tabuleiro (array bidimensional)
        -:   21:} *TABELA;
        -:   22:
        -:   23:// Estrutura que agrupa o estado do jogo e o tabuleiro
        -:   24:typedef struct
        -:   25:{
        -:   26:    ESTADO estado; // Estado do programa
        -:   27:    TABELA tab;    // Tabuleiro do jogo
        -:   28:} GAME;
        -:   29:
        -:   30:// Função que cria e aloca o tabuleiro com as dimensões fornecidas
        8:   31:void initTabela(TABELA t, int l, int c)
        -:   32:{
        8:   33:    t->l = l;
        8:   34:    t->c = c;
        8:   35:    t->tabela = malloc(l * sizeof(char *));
       26:   36:    for (int i = 0; i < l; i++)
        -:   37:    {
       18:   38:        t->tabela[i] = malloc((c + 1) * sizeof(char)); // + 1 para colocar o '\0'
       80:   39:        for (int j = 0; j <= c; j++)
        -:   40:        {
       62:   41:            if (j == c)
       18:   42:                t->tabela[i][j] = '\0';
        -:   43:            else
       44:   44:                t->tabela[i][j] = ' '; // Inicializa com espaços
        -:   45:        }
        -:   46:    }
        8:   47:}
        -:   48:
        -:   49:// Função para libertar a memória alocada para um tabuleiro
        8:   50:void freeTabela(TABELA t)
        -:   51:{
        8:   52:    if (t == NULL)
        -:   53:        return;
       26:   54:    for (int i = 0; i < t->l; i++)
        -:   55:    {
       18:   56:        free(t->tabela[i]);
        -:   57:    }
        8:   58:    free(t->tabela);
        8:   59:    free(t);
        -:   60:}
        -:   61:
        -:   62:// Tipo de função para comandos. Agora os comandos recebem um GAME* para acessar o estado e o tabuleiro.
        -:   63:typedef bool (*COMANDO)(char cmd, char *arg, GAME *game);
        -:   64:
        -:   65:// Comando para gravar o estado do jogo num ficheiro
        5:   66:bool gravar(char cmd, char *arg, GAME *game)
        -:   67:{
        5:   68:    if (cmd == 'g')
        -:   69:    {
        4:   70:        if (arg == NULL)
        -:   71:        {
        1:   72:            fprintf(stderr, "Erro: o comando gravar precisa de um argumento!\n");
        1:   73:            return false;
        -:   74:        }
        3:   75:        if (game->tab == NULL)
        -:   76:        {
        1:   77:            fprintf(stderr, "Erro: a tabela não ser nula antes de a gravar!\n");
        1:   78:            return false;
        -:   79:        }
        2:   80:        FILE *f = fopen(arg, "w"); // Abre o ficheiro (caso existe o que estiver lá escrito vai ser sobrescrito)
        2:   81:        if (f == NULL)
        -:   82:        {
        1:   83:            fprintf(stderr, "Erro a abrir o ficheiro");
        1:   84:            return false;
        -:   85:        }
        1:   86:        fprintf(f, "%d %d\n", game->tab->l, game->tab->c);
        3:   87:        for (int i = 0; i < game->tab->l; i++)
        -:   88:        {
        2:   89:            fprintf(f, "%s\n", game->tab->tabela[i]);
        -:   90:        }
        1:   91:        fclose(f);
        1:   92:        printf("Gravado em %s\n", arg);
        1:   93:        return true;
        -:   94:    }
        -:   95:
        -:   96:    return false;
        -:   97:}
        -:   98:
        -:   99:// Comando para sair
        2:  100:bool sair(char cmd, char *arg, GAME *game)
        -:  101:{
        2:  102:    if (arg != NULL)
        -:  103:        return false;
        1:  104:    if (cmd == 's')
        -:  105:    {
        1:  106:        game->estado.looping = false;
        1:  107:        return true;
        -:  108:    }
        -:  109:    return false;
        -:  110:}
        -:  111:
        -:  112:// Comando para ler o tabuleiro de um ficheiro
        4:  113:bool lerCmd(char cmd, char *arg, GAME *game)
        -:  114:{
        4:  115:    if (cmd != 'l' || arg == NULL)
        -:  116:        return false;
        -:  117:
        4:  118:    FILE *file = fopen(arg, "r"); // r é para leitura
        4:  119:    if (!file)
        -:  120:    {
        1:  121:        fprintf(stderr, "Erro ao abrir o ficheiro %s para leitura\n", arg);
        1:  122:        return false;
        -:  123:    }
        -:  124:
        3:  125:    int linhas, colunas;
        -:  126:    // Tenta ler as dimensões do tabuleiro
        3:  127:    if (fscanf(file, "%d %d", &linhas, &colunas) != 2)
        -:  128:    {
        1:  129:        fprintf(stderr, "Erro na leitura das dimensões do tabuleiro\n");
        1:  130:        fclose(file);
        1:  131:        return false;
        -:  132:    }
        -:  133:
        2:  134:    if (game->tab != NULL)
    #####:  135:        freeTabela(game->tab);
        -:  136:
        2:  137:    TABELA t = malloc(sizeof(struct Tabela));
        -:  138:
        2:  139:    initTabela(t, linhas, colunas);
        -:  140:
        -:  141:    // Lê o conteúdo do tabuleiro do ficheiro e passa-o para t
        4:  142:    for (int i = 0; i < linhas; i++)
        -:  143:    {
        8:  144:        for (int j = 0; j < colunas; j++)
        -:  145:        {
        6:  146:            if (fscanf(file, " %c", &t->tabela[i][j]) != 1)
        -:  147:            {
        1:  148:                fprintf(stderr, "Erro na leitura do conteúdo do tabuleiro\n");
        1:  149:                freeTabela(t);
        1:  150:                fclose(file);
        1:  151:                return false;
        -:  152:            }
        -:  153:        }
        -:  154:    }
        -:  155:
        1:  156:    fclose(file);
        1:  157:    game->tab = t;
        1:  158:    return true;
        -:  159:}
        -:  160:
        -:  161:// Converte coordenada do formato "a3" para índices numéricos (linha e coluna)
        3:  162:bool coordenadaParaIndice(const char *coord, int *linha, int *coluna)
        -:  163:{
        3:  164:    if (strlen(coord) < 2)
        -:  165:        return false;
        2:  166:    *coluna = coord[0] - 'a';     // 'a' corresponde à coluna 0
        2:  167:    *linha = atoi(coord + 1) - 1; // atoi (ascii to integer):  atoi -> converte uma string para um int   NOTA (coord + 1) é para comecar na segunda letra da string, e tirmaos 1, por causa do indice zero
        2:  168:    return true;
        -:  169:}
        -:  170:
        -:  171:// Pinta de branco (transforma para maiuscula)
        3:  172:bool pintarBranco(TABELA t, int linha, int coluna)
        -:  173:{
        3:  174:    if (linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c)
        -:  175:    {
        1:  176:        t->tabela[linha][coluna] = toupper(t->tabela[linha][coluna]);
        1:  177:        return true;
        -:  178:    }
        -:  179:    return false;
        -:  180:}
        -:  181:
        -:  182:// Risca a casa (substitui por '#')
        3:  183:bool riscar(TABELA t, int linha, int coluna)
        -:  184:{
        3:  185:    if (linha < 0 || linha >= t->l || coluna < 0 || coluna >= t->c)
        -:  186:        return false;
        -:  187:
        1:  188:    t->tabela[linha][coluna] = '#'; // Marca a célula com '#'
        1:  189:    return true;
        -:  190:}
        -:  191:
        -:  192:// Função que mostra o tabuleiro
        2:  193:void mostrarTabela(TABELA t)
        -:  194:{
        2:  195:    if (t == NULL)
        -:  196:    {
        1:  197:        printf("Tabuleiro não inicializado.\n");
        1:  198:        return;
        -:  199:    }
        4:  200:    for (int i = 0; i < t->l; i++)
        -:  201:    {
       12:  202:        for (int j = 0; j < t->c; j++)
        -:  203:        {
        9:  204:            printf("%c ", t->tabela[i][j]);
        -:  205:        }
        3:  206:        printf("\n");
        -:  207:    }
        -:  208:}
