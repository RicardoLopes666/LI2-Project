        -:    0:Source:parte1/parte1.c
        -:    0:Graph:parte1/parte1.gcno
        -:    0:Data:parte1/parte1.gcda
        -:    0:Runs:2
        -:    1:#include <assert.h>
        -:    2:#include <stdbool.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include "../tipos.h"
        -:    7:#include <ctype.h> // Para toupper
        -:    8:#include "../parte2/parte2.h"
        -:    9:#define LINE_SIZE 1024
        -:   10:
        -:   11:// Função que cria e aloca o tabuleiro com as dimensões fornecidas
       16:   12:void initTabela(TABELA t, int l, int c)
        -:   13:{
       16:   14:    t->l = l;
       16:   15:    t->c = c;
       16:   16:    t->tabela = malloc(l * sizeof(char *));
       50:   17:    for (int i = 0; i < l; i++)
        -:   18:    {
       34:   19:        t->tabela[i] = malloc((c + 1) * sizeof(char)); // + 1 para colocar o '\0'
      150:   20:        for (int j = 0; j <= c; j++)
        -:   21:        {
      116:   22:            if (j == c)
       34:   23:                t->tabela[i][j] = '\0';
        -:   24:            else
       82:   25:                t->tabela[i][j] = ' '; // Inicializa com espaços
        -:   26:        }
        -:   27:    }
       16:   28:}
        -:   29:
        -:   30:// Função para libertar a memória alocada para um tabuleiro
       54:   31:void freeTabela(TABELA t)
        -:   32:{
       54:   33:    if (t == NULL)
        -:   34:        return;
      182:   35:    for (int i = 0; i < t->l; i++)
        -:   36:    {
      128:   37:        free(t->tabela[i]);
        -:   38:    }
       54:   39:    free(t->tabela);
       54:   40:    free(t);
        -:   41:}
        -:   42:
        -:   43:// Tipo de função para comandos. Agora os comandos recebem um GAME* para acessar o estado e o tabuleiro.
        -:   44:typedef bool (*COMANDO)(char cmd, char *arg, GAME *game);
        -:   45:
        -:   46:// Função responsável por escrever no ficheiro o conteúdo de uma tabela
        2:   47:void escreveTabela(TABELA tabela, FILE *f)
        -:   48:{
        2:   49:    fprintf(f, "%d %d\n", tabela->l, tabela->c);
        6:   50:    for (int i = 0; i < tabela->l; i++)
        -:   51:    {
        4:   52:        fprintf(f, "%s\n", tabela->tabela[i]);
        -:   53:    }
        2:   54:    putchar('\n');
        2:   55:}
        -:   56:
        -:   57:// Comando para gravar o estado do jogo num ficheiro
       10:   58:bool gravar(char cmd, char *arg, GAME *game)
        -:   59:{
       10:   60:    if (cmd == 'g')
        -:   61:    {
        8:   62:        if (arg == NULL)
        -:   63:        {
        2:   64:            fprintf(stderr, "Erro: o comando gravar precisa de um argumento!\n");
        2:   65:            return false;
        -:   66:        }
        6:   67:        if (game->tab == NULL)
        -:   68:        {
        2:   69:            fprintf(stderr, "Erro: a tabela não deve ser nula antes de a gravar!\n");
        2:   70:            return false;
        -:   71:        }
        4:   72:        FILE *f = fopen(arg, "w"); // Abre o ficheiro (caso existe o que estiver lá escrito vai ser sobrescrito)
        4:   73:        if (f == NULL)
        -:   74:        {
        2:   75:            fprintf(stderr, "Erro a abrir o ficheiro");
        2:   76:            return false;
        -:   77:        }
        4:   78:        for (int i = 0; i < game->stackTabs->comprimento; i++)
        -:   79:        {
        2:   80:            escreveTabela(game->stackTabs->tabelas[i], f);
        -:   81:        }
        2:   82:        fclose(f);
        2:   83:        printf("Gravado em %s\n", arg);
        2:   84:        return true;
        -:   85:    }
        -:   86:
        -:   87:    return false;
        -:   88:}
        -:   89:
        -:   90:// Comando para sair
        4:   91:bool sair(char cmd, char *arg, GAME *game)
        -:   92:{
        4:   93:    if (arg != NULL)
        -:   94:        return false;
        2:   95:    if (cmd == 's')
        -:   96:    {
        2:   97:        game->estado.looping = false;
        2:   98:        return true;
        -:   99:    }
        -:  100:    return false;
        -:  101:}
        -:  102:
        4:  103:bool leTabuleiro(TABELA *t, int linhas, int colunas, FILE *file)
        -:  104:{
        8:  105:    for (int i = 0; i < linhas; i++)
        -:  106:    {
       16:  107:        for (int j = 0; j < colunas; j++)
        -:  108:        {
       12:  109:            if (fscanf(file, " %c", &(*t)->tabela[i][j]) != 1)
        -:  110:            {
        2:  111:                fprintf(stderr, "Erro: na leitura do conteúdo do tabuleiro\n");
        2:  112:                return false;
        -:  113:            }
        -:  114:        }
        -:  115:    }
        -:  116:    return true;
        -:  117:}
        -:  118:
        2:  119:bool colocaTabelaNaStack(GAME *game, TABELA tabela)
        -:  120:{
        2:  121:    if (!insereTabela(game->stackTabs, tabela))
        -:  122:    {
    #####:  123:        if (tabela)
    #####:  124:            freeTabela(tabela);
    #####:  125:        freeStackTabs(game->stackTabs);
    #####:  126:        fprintf(stderr, "Erro: na criação da stack de tabuleiros");
    #####:  127:        return false;
        -:  128:    }
        -:  129:    return true;
        -:  130:}
        -:  131:
        -:  132:// Comando para ler o tabuleiro de um ficheiro
       12:  133:bool lerCmd(char cmd, char *arg, GAME *game)
        -:  134:{
       12:  135:    if (cmd != 'l' || arg == NULL)
        -:  136:        return false;
        -:  137:
        8:  138:    FILE *file = fopen(arg, "r"); // r é para leitura
        8:  139:    if (!file)
        -:  140:    {
        2:  141:        fprintf(stderr, "Erro: ao abrir o ficheiro %s para leitura\n", arg);
        2:  142:        return false;
        -:  143:    }
        -:  144:
        6:  145:    freeStackTabs(game->stackTabs);
        6:  146:    STACKTABS s = malloc(sizeof(struct StackTabs));
        6:  147:    if (!initStackTabs(s))
        -:  148:    {
    #####:  149:        free(s);
    #####:  150:        return false;
        -:  151:    }
        6:  152:    game->stackTabs = s;
        -:  153:
        6:  154:    int linhas, colunas;
        -:  155:    // Loop que le os vários tabuleiros enquanto o ficheiro não estiver vazio e coloca-os da stackTabs
        8:  156:    while (fscanf(file, "%d %d", &linhas, &colunas) == 2)
        -:  157:    {
        4:  158:        TABELA t = malloc(sizeof(struct Tabela));
        -:  159:
        4:  160:        initTabela(t, linhas, colunas);
        -:  161:
        -:  162:        // Lê o conteúdo do tabuleiro do ficheiro e passa-o para a tabela t
        4:  163:        if (!leTabuleiro(&t, linhas, colunas, file) || !colocaTabelaNaStack(game, t))
        -:  164:        {
        2:  165:            freeTabela(t);
        2:  166:            freeStackTabs(s);
        2:  167:            fclose(file);
        2:  168:            return false;
        -:  169:        }
        -:  170:    }
        4:  171:    if (game->stackTabs->comprimento == 0)
        -:  172:    {
        2:  173:        printf("Erro: tabuleiro não contem nenhum tabuleiro");
        2:  174:        fclose(file);
        2:  175:        return false;
        -:  176:    }
        -:  177:
        2:  178:    fclose(file);
        2:  179:    if (game->tab != NULL)
    #####:  180:        freeTabela(game->tab);
        2:  181:    TABELA temp = copiarTabela(game->stackTabs->tabelas[game->stackTabs->comprimento - 1]);
        2:  182:    if (temp != NULL)
        2:  183:        game->tab = temp;
        -:  184:    else
        -:  185:        return false;
        2:  186:    return true;
        -:  187:}
        -:  188:
        -:  189:// Converte coordenada do formato "a3" para  coordenadas (linha e coluna)
        6:  190:bool coordenadaParaIndice(const char *coord, int *linha, int *coluna)
        -:  191:{
        6:  192:    if (strlen(coord) < 2)
        -:  193:        return false;
        4:  194:    *coluna = coord[0] - 'a';     // 'a' corresponde à coluna 0
        4:  195:    *linha = atoi(coord + 1) - 1; // atoi (ascii to integer):  atoi -> converte uma string para um int   NOTA (coord + 1) é para comecar na segunda letra da string, e tirmaos 1, por causa do indice zero
        4:  196:    return true;
        -:  197:}
        -:  198:
        -:  199:// Pinta de branco (transforma para maiuscula)
        6:  200:bool pintarBranco(TABELA t, int linha, int coluna)
        -:  201:{
        6:  202:    if (linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c)
        -:  203:    {
        2:  204:        t->tabela[linha][coluna] = toupper(t->tabela[linha][coluna]);
        2:  205:        return true;
        -:  206:    }
        -:  207:    return false;
        -:  208:}
        -:  209:
        -:  210:// Risca a casa (substitui por '#')
        6:  211:bool riscar(TABELA t, int linha, int coluna)
        -:  212:{
        6:  213:    if (linha < 0 || linha >= t->l || coluna < 0 || coluna >= t->c)
        -:  214:        return false;
        -:  215:
        2:  216:    t->tabela[linha][coluna] = '#'; // Marca a célula com '#'
        2:  217:    return true;
        -:  218:}
        -:  219:
        -:  220:// Função que mostra o tabuleiro
        4:  221:void mostrarTabela(TABELA t)
        -:  222:{
        4:  223:    printf("\nEstado atual do tabuleiro:\n");
        4:  224:    if (t == NULL)
        -:  225:    {
        2:  226:        printf("Tabuleiro não inicializado.\n");
        2:  227:        return;
        -:  228:    }
        8:  229:    for (int i = 0; i < t->l; i++)
        -:  230:    {
       24:  231:        for (int j = 0; j < t->c; j++)
        -:  232:        {
       18:  233:            printf("%c ", t->tabela[i][j]);
        -:  234:        }
        6:  235:        printf("\n");
        -:  236:    }
        -:  237:}
