        -:    0:Source:parte1/parte1.c
        -:    0:Graph:parte1/parte1.gcno
        -:    0:Data:parte1/parte1.gcda
        -:    0:Runs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdbool.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include "../tipos.h"
        -:    7:#include <ctype.h> // Para toupper
        -:    8:#include "../parte2/parte2.h"
        -:    9:#include "../parte4/parte4.h"
        -:   10:#include "../colors.h"
        -:   11:#define LINE_SIZE 1024
        -:   12:
        -:   13:// Função que cria e aloca o tabuleiro com as dimensões fornecidas
       18:   14:void initTabela(TABELA t, int l, int c)
        -:   15:{
       18:   16:    t->l = l;
       18:   17:    t->c = c;
       18:   18:    t->tabela = malloc(l * sizeof(char *));
       49:   19:    for (int i = 0; i < l; i++)
        -:   20:    {
       31:   21:        t->tabela[i] = malloc((c + 1) * sizeof(char)); // + 1 para colocar o '\0'
      127:   22:        for (int j = 0; j <= c; j++)
        -:   23:        {
       96:   24:            if (j == c)
       31:   25:                t->tabela[i][j] = '\0';
        -:   26:            else
       65:   27:                t->tabela[i][j] = ' '; // Inicializa com espaços
        -:   28:        }
        -:   29:    }
       18:   30:}
        -:   31:
        -:   32:// Função para libertar a memória alocada para um tabuleiro
      109:   33:void freeTabela(TABELA t)
        -:   34:{
      109:   35:    if (t == NULL)
        -:   36:        return;
      301:   37:    for (int i = 0; i < t->l; i++)
        -:   38:    {
      193:   39:        free(t->tabela[i]);
        -:   40:    }
      108:   41:    free(t->tabela);
      108:   42:    free(t);
        -:   43:}
        -:   44:
        -:   45:// Tipo de função para comandos. Agora os comandos recebem um GAME* para acessar o estado e o tabuleiro.
        -:   46:typedef bool (*COMANDO)(char cmd, char *arg, GAME *game);
        -:   47:
        -:   48:// Função responsável por escrever no ficheiro o conteúdo de uma tabela
        1:   49:void escreveTabela(TABELA tabela, FILE *f)
        -:   50:{
        1:   51:    fprintf(f, "%d %d\n", tabela->l, tabela->c);
        3:   52:    for (int i = 0; i < tabela->l; i++)
        -:   53:    {
        2:   54:        fprintf(f, "%s\n", tabela->tabela[i]);
        -:   55:    }
        1:   56:    putchar('\n');
        1:   57:}
        -:   58:
        -:   59:// Comando para gravar o estado do jogo num ficheiro
        5:   60:bool gravar(char cmd, char *arg, GAME *game)
        -:   61:{
        5:   62:    if (cmd == 'g')
        -:   63:    {
        4:   64:        if (arg == NULL)
        -:   65:        {
        1:   66:            fprintf(stderr, "%sErro: o comando gravar precisa de um argumento!%s\n", ERROR_COLOR, RESET);
        1:   67:            return false;
        -:   68:        }
        3:   69:        if (game->tab == NULL)
        -:   70:        {
        1:   71:            fprintf(stderr, "%sErro: a tabela não deve ser nula antes de a gravar!%s\n", ERROR_COLOR, RESET);
        1:   72:            return false;
        -:   73:        }
        2:   74:        FILE *f = fopen(arg, "w"); // Abre o ficheiro (caso existe o que estiver lá escrito vai ser sobrescrito)
        2:   75:        if (f == NULL)
        -:   76:        {
        1:   77:            fprintf(stderr, "%sErro: a abrir o ficheiro%s\n", ERROR_COLOR, RESET);
        1:   78:            return false;
        -:   79:        }
        2:   80:        for (int i = 0; i < game->stackTabs->comprimento; i++)
        -:   81:        {
        1:   82:            escreveTabela(game->stackTabs->tabelas[i], f);
        -:   83:        }
        1:   84:        fclose(f);
        1:   85:        printf("Gravado em %s\n", arg);
        1:   86:        return true;
        -:   87:    }
        -:   88:
        -:   89:    return false;
        -:   90:}
        -:   91:
        -:   92:// Comando para sair
        2:   93:bool sair(char cmd, char *arg, GAME *game)
        -:   94:{
        2:   95:    if (arg != NULL)
        -:   96:        return false;
        1:   97:    if (cmd == 's')
        -:   98:    {
        1:   99:        game->estado.looping = false;
        1:  100:        return true;
        -:  101:    }
        -:  102:    return false;
        -:  103:}
        -:  104:
        2:  105:bool leTabuleiro(TABELA *t, int linhas, int colunas, FILE *file)
        -:  106:{
        3:  107:    for (int i = 0; i < linhas; i++)
        -:  108:    {
        4:  109:        for (int j = 0; j < colunas; j++)
        -:  110:        {
        3:  111:            if (fscanf(file, " %c", &(*t)->tabela[i][j]) != 1)
        -:  112:            {
        1:  113:                fprintf(stderr, "%sErro: na leitura do conteúdo do tabuleiro%s\n", ERROR_COLOR, RESET);
        1:  114:                return false;
        -:  115:            }
        -:  116:        }
        -:  117:    }
        -:  118:    return true;
        -:  119:}
        -:  120:
        1:  121:bool colocaTabelaNaStack(GAME *game, TABELA tabela)
        -:  122:{
        1:  123:    if (!insereTabela(game->stackTabs, tabela))
        -:  124:    {
    #####:  125:        if (tabela)
    #####:  126:            freeTabela(tabela);
    #####:  127:        freeStackTabs(game->stackTabs);
    #####:  128:        fprintf(stderr, "%sErro: na criação da stack de tabuleiros%s\n", ERROR_COLOR, RESET);
    #####:  129:        return false;
        -:  130:    }
        -:  131:    return true;
        -:  132:}
        -:  133:
        2:  134:void colocaSolucao(GAME *game)
        -:  135:{
        2:  136:    TABELA aux = resolve(game->stackTabs->tabelas[0]); // Recebe a primeira tabela carregada (em principio so com letras minusculas)
        -:  137:
        2:  138:    TABELA temp = game->solution;
        2:  139:    game->solution = aux;
        2:  140:    if (temp != NULL)
        1:  141:        freeTabela(temp);
        2:  142:}
        -:  143:
        -:  144:// Comando para ler o tabuleiro de um ficheiro
        4:  145:bool lerCmd(char cmd, char *arg, GAME *game)
        -:  146:{
        4:  147:    if (cmd != 'l' || arg == NULL)
        -:  148:        return false;
        -:  149:
        4:  150:    FILE *file = fopen(arg, "r"); // r é para leitura
        4:  151:    if (!file)
        -:  152:    {
        1:  153:        fprintf(stderr, "%sErro: ao abrir o ficheiro %s para leitura%s\n", ERROR_COLOR, arg, RESET);
        1:  154:        return false;
        -:  155:    }
        -:  156:
        3:  157:    freeStackTabs(game->stackTabs);
        3:  158:    STACKTABS s = malloc(sizeof(struct StackTabs));
        3:  159:    if (!initStackTabs(s))
        -:  160:    {
    #####:  161:        free(s);
    #####:  162:        return false;
        -:  163:    }
        3:  164:    game->stackTabs = s;
        -:  165:
        3:  166:    int linhas, colunas;
        -:  167:    // Loop que le os vários tabuleiros enquanto o ficheiro não estiver vazio e coloca-os na stackTabs
        4:  168:    while (fscanf(file, "%d %d", &linhas, &colunas) == 2)
        -:  169:    {
        2:  170:        TABELA t = malloc(sizeof(struct Tabela));
        -:  171:
        2:  172:        initTabela(t, linhas, colunas);
        -:  173:
        -:  174:        // Lê o conteúdo do tabuleiro do ficheiro e passa-o para a tabela t
        2:  175:        if (!leTabuleiro(&t, linhas, colunas, file) || !colocaTabelaNaStack(game, t))
        -:  176:        {
        1:  177:            freeTabela(t);
        1:  178:            freeStackTabs(s);
        1:  179:            fclose(file);
        1:  180:            return false;
        -:  181:        }
        -:  182:    }
        2:  183:    if (game->stackTabs->comprimento == 0)
        -:  184:    {
        1:  185:        printf("%sErro: o ficheiro não contem nenhum tabuleiro%s", ERROR_COLOR, RESET);
        1:  186:        fclose(file);
        1:  187:        return false;
        -:  188:    }
        -:  189:
        1:  190:    fclose(file);
        1:  191:    if (game->tab != NULL)
        1:  192:        freeTabela(game->tab);
        1:  193:    TABELA temp = copiarTabela(game->stackTabs->tabelas[game->stackTabs->comprimento - 1]);
        -:  194:
        1:  195:    if (temp != NULL)
        1:  196:        game->tab = temp;
        -:  197:    else
        -:  198:        return false;
        1:  199:    colocaSolucao(game);
        -:  200:
        1:  201:    return true;
        -:  202:}
        -:  203:
        -:  204:// Converte coordenada do formato "a3" para  coordenadas (linha e coluna)
        3:  205:bool coordenadaParaIndice(const char *coord, int *linha, int *coluna)
        -:  206:{
        3:  207:    if (strlen(coord) < 2)
        -:  208:        return false;
        2:  209:    *coluna = coord[0] - 'a';     // 'a' corresponde à coluna 0
        2:  210:    *linha = atoi(coord + 1) - 1; // atoi (ascii to integer):  atoi -> converte uma string para um int   NOTA (coord + 1) é para comecar na segunda letra da string, e tirmaos 1, por causa do indice zero
        2:  211:    return true;
        -:  212:}
        -:  213:
        -:  214:// Pinta de branco (transforma para maiuscula)
        4:  215:bool pintarBranco(TABELA t, int linha, int coluna, TABELA p) // p é a primeira tabela carregada
        -:  216:{
        4:  217:    if (linha >= 0 && linha < t->l && coluna >= 0 && coluna < t->c)
        -:  218:    {
        2:  219:        if (t->tabela[linha][coluna] != '#')
        1:  220:            t->tabela[linha][coluna] = toupper(t->tabela[linha][coluna]);
        -:  221:        else
        1:  222:            t->tabela[linha][coluna] = toupper(p->tabela[linha][coluna]);
        2:  223:        return true;
        -:  224:    }
        -:  225:    return false;
        -:  226:}
        -:  227:
        -:  228:// Risca a casa (substitui por '#')
        3:  229:bool riscar(TABELA t, int linha, int coluna)
        -:  230:{
        3:  231:    if (linha < 0 || linha >= t->l || coluna < 0 || coluna >= t->c)
        -:  232:        return false;
        -:  233:
        1:  234:    t->tabela[linha][coluna] = '#'; // Marca a célula com '#'
        1:  235:    return true;
        -:  236:}
        -:  237:
        -:  238:// Função que mostra o tabuleiro
        3:  239:void mostrarTabela(GAME game, int isC) // isC é uma flag que se for positiva quer dizer que estou a invocar o comando c
        -:  240:{
        3:  241:    TABELA t = game.tab;
        3:  242:    TABELA s = game.solution;
        3:  243:    if (!isC)
        2:  244:        printf("\n%sEstado atual do tabuleiro:%s\n", COMMAND_COLOR, RESET);
        3:  245:    if (t == NULL)
        -:  246:    {
        1:  247:        printf("%sTabuleiro não inicializado.%s\n", ERROR_COLOR, RESET);
        1:  248:        return;
        -:  249:    }
        -:  250:
        -:  251:    // Desenha os headers (a, b, c, ..)
        2:  252:    printf("    ");
        6:  253:    for (int j = 0; j < t->c; j++)
        4:  254:        printf(" %s%c%s  ", COORDINATE_COLOR, 'a' + j, RESET);
        2:  255:    printf("\n");
        -:  256:
        -:  257:    // Desenha a primeira linha da tabela
        2:  258:    printf("   ┏");
        6:  259:    for (int j = 0; j < t->c; j++)
        8:  260:        printf("━━━%s", (j == t->c - 1) ? "┓\n" : "┳");
        -:  261:
        6:  262:    for (int i = 0; i < t->l; i++)
        -:  263:    {
        -:  264:        // Escreve o numero da linha
        4:  265:        printf("%s%2d%s ┃", COORDINATE_COLOR, i + 1, RESET);
        -:  266:
       12:  267:        for (int j = 0; j < t->c; j++)
        -:  268:        {
        8:  269:            char cell = t->tabela[i][j];
        8:  270:            int igual = t->tabela[i][j] == s->tabela[i][j];
        8:  271:            if (cell == '#')
        -:  272:            {
       1*:  273:                isC ? printf("%s # %s", igual ? CAPITAL_GREEN : CAPITAL_RED, RESET) : printf("%s # %s", HASHED_CELL, RESET);
        -:  274:            }
        7:  275:            else if (isupper(cell))
        -:  276:            {
        8:  277:                isC ? printf("%s[%c]%s", igual ? CAPITAL_GREEN : CAPITAL_RED, cell, RESET) : printf("%s[%c]%s", CAPITAL_LETTER, cell, RESET);
        -:  278:            }
        -:  279:            else
    #####:  280:                printf(" %s%c%s ", NORMAL_LETTER, cell, RESET);
        8:  281:            printf("┃");
        -:  282:        }
        4:  283:        printf("\n");
        -:  284:
        4:  285:        if (i < t->l - 1)
        -:  286:        {
        -:  287:            // Desenha linha entre as diferentes linhas do tabuleiro
        2:  288:            printf("   ┣");
        6:  289:            for (int j = 0; j < t->c; j++)
        8:  290:                printf("━━━%s", (j == t->c - 1) ? "┫\n" : "╋");
        -:  291:        }
        -:  292:    }
        -:  293:
        -:  294:    // Desenha a linha inferior
        2:  295:    printf("   ┗");
        6:  296:    for (int j = 0; j < t->c; j++)
        8:  297:        printf("━━━%s", (j == t->c - 1) ? "┛\n" : "┻");
        2:  298:    printf("\n");
        -:  299:}
        -:  300:
        1:  301:void i(GAME *game, bool *comandoProcessado)
        -:  302:{
        1:  303:    TABELA new = copiarTabela(game->stackTabs->tabelas[0]);
        1:  304:    if (new)
        -:  305:    {
        1:  306:        TABELA temp = game->tab;
        1:  307:        game->tab = new;
        1:  308:        freeTabela(temp);
        -:  309:    }
        1:  310:    *comandoProcessado = true;
        1:  311:}
        -:  312:
        1:  313:void e(GAME g, bool *comandoProcessado)
        -:  314:{
        1:  315:    int total = g.tab->c * g.tab->l;
        1:  316:    int corretas = 0;
        1:  317:    int r = 0, b = 0;
        2:  318:    for (int i = 0; i < g.tab->l; i++)
        -:  319:    {
        3:  320:        for (int j = 0; j < g.tab->c; j++)
        -:  321:        {
        2:  322:            int cel = g.tab->tabela[i][j];
        2:  323:            if (!islower(cel))
        -:  324:            {
        1:  325:                if (cel == g.solution->tabela[i][j])
        1:  326:                    corretas++;
        1:  327:                if (isupper(cel))
        1:  328:                    b++;
    #####:  329:                else if (cel == '#')
    #####:  330:                    r++;
        -:  331:            }
        -:  332:        }
        -:  333:    }
        -:  334:
        1:  335:    int resolvidas = r + b;
        1:  336:    float percentagem = ((float)resolvidas / (float)total) * (float)100;
        1:  337:    printf("\n%s=== ESTATÍSTICAS DO JOGO ===%s\n", HINT_COLOR, RESET);
        -:  338:
        1:  339:    printf("\n%sEstado do Tabuleiro%s\n", BLUE, RESET);
        1:  340:    printf("  Dimensões: %dx%d (%d casas)\n", g.tab->l, g.tab->c, total);
        1:  341:    printf("  Casas resolvidas: %d/%d (%.1f%%)\n", resolvidas, total, percentagem);
        1:  342:    printf("  Casas por resolver: %d\n", total - resolvidas);
        1:  343:    printf("  Casas corretamente colocadas: %d (para mais informações use o comando 'c')\n", corretas);
        -:  344:
        1:  345:    printf("\n%sDistribuição:%s\n", BLUE, RESET);
        1:  346:    printf("  Casas brancas: %d\n", b);
        1:  347:    printf("  Casas riscadas: %d\n", r);
        -:  348:
        1:  349:    bool temResticoes = verificaRestricoes(g.tab, false);
        -:  350:
        1:  351:    printf("\n%sValidação:%s\n", BLUE, RESET);
        1:  352:    if (!temResticoes)
        1:  353:        printf("  Estado: Válido\n");
        -:  354:    else
    #####:  355:        printf("  Foram encontradas violações das regras (para mais informações utilize o comando 'v')\n");
        -:  356:
        1:  357:    *comandoProcessado = true;
        1:  358:}
